diff --git a/Android.mk b/Android.mk
index 9c9a160..fe664ab 100644
--- a/Android.mk
+++ b/Android.mk
@@ -123,8 +123,11 @@ LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
 
 LOCAL_MODULE := SDL2_main
 
-LOCAL_MODULE_FILENAME := libSDL2main
+LOCAL_SRC_FILES := \
+	$(wildcard $(LOCAL_PATH)/src/main/android/*.c)
 
-include $(BUILD_STATIC_LIBRARY)
+LOCAL_MODULE_FILENAME := libmain
+
+include $(BUILD_SHARED_LIBRARY)
 
 $(call import-module,android/cpufeatures)
diff --git a/android-project/app/src/main/java/org/libsdl/app/SDLAudioManager.java b/android-project/app/src/main/java/org/libsdl/app/SDLAudioManager.java
index 7c821a4..192ade5 100644
--- a/android-project/app/src/main/java/org/libsdl/app/SDLAudioManager.java
+++ b/android-project/app/src/main/java/org/libsdl/app/SDLAudioManager.java
@@ -77,6 +77,16 @@ public class SDLAudioManager {
         int frameSize;
 
         Log.v(TAG, "Opening " + (isCapture ? "capture" : "playback") + ", requested " + desiredFrames + " frames of " + desiredChannels + " channel " + getAudioFormatString(audioFormat) + " audio at " + sampleRate + " Hz");
+        
+        // Get native sample rate for better audio quality
+        if (!isCapture && mContext != null && Build.VERSION.SDK_INT >= 17 /* Android 4.2 (JELLY_BEAN_MR1) */) {
+            AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
+            String nativeSampleRateStr = am.getProperty(AudioManager.PROPERTY_OUTPUT_SAMPLE_RATE);
+            if (nativeSampleRateStr != null) {
+                int nativeSampleRate = Integer.parseInt(nativeSampleRateStr);
+                Log.v(TAG, "Device native sample rate: " + nativeSampleRate + " Hz, requested: " + sampleRate + " Hz");
+            }
+        }
 
         /* On older devices let's use known good settings */
         if (Build.VERSION.SDK_INT < 21 /* Android 5.0 (LOLLIPOP) */) {
@@ -221,6 +231,11 @@ public class SDLAudioManager {
             minBufferSize = AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat);
         }
         desiredFrames = Math.max(desiredFrames, (minBufferSize + frameSize - 1) / frameSize);
+        
+        // Increase buffer size to reduce audio glitches/crackling on Android
+        // Especially important for emulated games that may have timing variations
+        desiredFrames = Math.max(desiredFrames, 4096);
+        Log.v(TAG, "Using buffer size: " + desiredFrames + " frames (min was " + ((minBufferSize + frameSize - 1) / frameSize) + ")");
 
         int[] results = new int[4];
 
@@ -250,7 +265,42 @@ public class SDLAudioManager {
 
         } else {
             if (mAudioTrack == null) {
-                mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate, channelConfig, audioFormat, desiredFrames * frameSize, AudioTrack.MODE_STREAM);
+                int bufferSizeInBytes = desiredFrames * frameSize;
+                
+                // Use modern AudioTrack.Builder API for better performance on Android 5.0+
+                if (Build.VERSION.SDK_INT >= 21 /* Android 5.0 (LOLLIPOP) */) {
+                    try {
+                        android.media.AudioAttributes audioAttributes = new android.media.AudioAttributes.Builder()
+                                .setUsage(android.media.AudioAttributes.USAGE_GAME)
+                                .setContentType(android.media.AudioAttributes.CONTENT_TYPE_SONIFICATION)
+                                .build();
+                        
+                        AudioFormat audioFormatObj = new AudioFormat.Builder()
+                                .setSampleRate(sampleRate)
+                                .setEncoding(audioFormat)
+                                .setChannelMask(channelConfig)
+                                .build();
+                        
+                        AudioTrack.Builder builder = new AudioTrack.Builder()
+                                .setAudioAttributes(audioAttributes)
+                                .setAudioFormat(audioFormatObj)
+                                .setBufferSizeInBytes(bufferSizeInBytes)
+                                .setTransferMode(AudioTrack.MODE_STREAM);
+                        
+                        // Set performance mode for lower latency on Android 8.0+
+                        if (Build.VERSION.SDK_INT >= 26 /* Android 8.0 (O) */) {
+                            builder.setPerformanceMode(AudioTrack.PERFORMANCE_MODE_LOW_LATENCY);
+                        }
+                        
+                        mAudioTrack = builder.build();
+                        Log.v(TAG, "Created AudioTrack using Builder API (SDK " + Build.VERSION.SDK_INT + ")");
+                    } catch (Exception e) {
+                        Log.e(TAG, "Failed to create AudioTrack with Builder, falling back to legacy: " + e.getMessage());
+                        mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate, channelConfig, audioFormat, bufferSizeInBytes, AudioTrack.MODE_STREAM);
+                    }
+                } else {
+                    mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate, channelConfig, audioFormat, bufferSizeInBytes, AudioTrack.MODE_STREAM);
+                }
 
                 // Instantiating AudioTrack can "succeed" without an exception and the track may still be invalid
                 // Ref: https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/media/java/android/media/AudioTrack.java
diff --git a/android-project/build.gradle b/android-project/build.gradle
index 2c911c6..2d877c3 100644
--- a/android-project/build.gradle
+++ b/android-project/build.gradle
@@ -17,6 +17,8 @@ allprojects {
     repositories {
         mavenCentral()
         google()
+
+
     }
 }
 
diff --git a/include/SDL_hints.h b/include/SDL_hints.h
index e775a65..6249be1 100644
--- a/include/SDL_hints.h
+++ b/include/SDL_hints.h
@@ -1853,6 +1853,26 @@ extern "C" {
  */
 #define SDL_HINT_TOUCH_MOUSE_EVENTS    "SDL_TOUCH_MOUSE_EVENTS"
 
+/**
+ *  \brief  A variable controlling whether multi-touch gestures should generate mouse events
+ *
+ *  This is a RALCore extension for touch-to-mouse conversion with multi-finger support:
+ *    "0"       - Single-touch mode: only first finger controls mouse (default)
+ *    "1"       - Multi-touch mode:
+ *                - Each finger touch sends mouse move + left button PRESSED event
+ *                - Each finger lift sends left button RELEASED event  
+ *                - SDL_mouse.c's button state check is bypassed for touch events
+ *                - This allows multiple simultaneous clicks at different positions
+ *                - The most recently touched finger controls mouse cursor movement
+ *
+ *  Implementation: When enabled, SDL_PrivateSendMouseButton in SDL_mouse.c skips
+ *  the "buttonstate == source->buttonstate" check for SDL_TOUCH_MOUSEID events,
+ *  allowing duplicate button press events from multiple touch points.
+ *
+ *  Requires SDL_TOUCH_MOUSE_EVENTS to be enabled ("1") to take effect.
+ */
+#define SDL_HINT_TOUCH_MOUSE_MULTITOUCH    "SDL_TOUCH_MOUSE_MULTITOUCH"
+
 /**
  *  \brief  A variable controlling which touchpad should generate synthetic mouse events
  *
diff --git a/src/SDL.c b/src/SDL.c
index 7065fe7..73fa8ad 100644
--- a/src/SDL.c
+++ b/src/SDL.c
@@ -569,7 +569,8 @@ const char *SDL_GetPlatform(void)
 #if defined(__AIX__)
     return "AIX";
 #elif defined(__ANDROID__)
-    return "Android";
+    // we spoof this on Android so games feels more at home
+    return "Linux";
 #elif defined(__BSDI__)
     return "BSDI";
 #elif defined(__DREAMCAST__)
diff --git a/src/SDL_assert.c b/src/SDL_assert.c
index 1ca41e7..2d55e1a 100644
--- a/src/SDL_assert.c
+++ b/src/SDL_assert.c
@@ -230,7 +230,7 @@ static SDL_assert_state SDLCALL SDL_PromptAssertion(const SDL_assert_data *data,
     window = SDL_GetFocusWindow();
     if (window) {
         if (SDL_GetWindowFlags(window) & SDL_WINDOW_FULLSCREEN) {
-            SDL_MinimizeWindow(window);
+//            SDL_MinimizeWindow(window);
         } else {
             /* !!! FIXME: ungrab the input if we're not fullscreen? */
             /* No need to mess with the window */
diff --git a/src/audio/aaudio/SDL_aaudio.c b/src/audio/aaudio/SDL_aaudio.c
index 401fef6..d4a4f00 100644
--- a/src/audio/aaudio/SDL_aaudio.c
+++ b/src/audio/aaudio/SDL_aaudio.c
@@ -78,7 +78,7 @@ static int aaudio_OpenDevice(_THIS, const char *devname)
     LOGI(__func__);
 
     SDL_assert((captureDevice == NULL) || !iscapture);
-    SDL_assert((audioDevice == NULL) || iscapture);
+//666    SDL_assert((audioDevice == NULL) || iscapture);
 
     if (iscapture) {
         if (!Android_JNI_RequestPermission("android.permission.RECORD_AUDIO")) {
@@ -116,7 +116,15 @@ static int aaudio_OpenDevice(_THIS, const char *devname)
     }
 
     ctx.AAudioStreamBuilder_setErrorCallback(ctx.builder, aaudio_errorCallback, private);
-    ctx.AAudioStreamBuilder_setPerformanceMode(ctx.builder, AAUDIO_PERFORMANCE_MODE_LOW_LATENCY);
+
+    /* Check environment variable for low latency mode */
+    {
+        const char *lowLatencyEnv = SDL_getenv("SDL_AAUDIO_LOW_LATENCY");
+        if (lowLatencyEnv && SDL_strcmp(lowLatencyEnv, "1") == 0) {
+            ctx.AAudioStreamBuilder_setPerformanceMode(ctx.builder, AAUDIO_PERFORMANCE_MODE_LOW_LATENCY);
+            LOGI("AAudio low latency mode enabled via SDL_AAUDIO_LOW_LATENCY");
+        }
+    }
 
     LOGI("AAudio Try to open %u hz %u bit chan %u %s samples %u",
          this->spec.freq, SDL_AUDIO_BITSIZE(this->spec.format),
@@ -193,7 +201,7 @@ static void aaudio_CloseDevice(_THIS)
         SDL_assert(captureDevice == this);
         captureDevice = NULL;
     } else {
-        SDL_assert(audioDevice == this);
+      //666   SDL_assert(audioDevice == this);
         audioDevice = NULL;
     }
 
@@ -239,7 +247,15 @@ static int RebuildAAudioStream(SDL_AudioDevice *device)
     }
 
     ctx.AAudioStreamBuilder_setErrorCallback(ctx.builder, aaudio_errorCallback, hidden);
-    ctx.AAudioStreamBuilder_setPerformanceMode(ctx.builder, AAUDIO_PERFORMANCE_MODE_LOW_LATENCY);
+
+    /* Check environment variable for low latency mode */
+    {
+        const char *lowLatencyEnv = SDL_getenv("SDL_AAUDIO_LOW_LATENCY");
+        if (lowLatencyEnv && SDL_strcmp(lowLatencyEnv, "1") == 0) {
+            ctx.AAudioStreamBuilder_setPerformanceMode(ctx.builder, AAUDIO_PERFORMANCE_MODE_LOW_LATENCY);
+            LOGI("AAudio low latency mode enabled via SDL_AAUDIO_LOW_LATENCY");
+        }
+    }
 
     LOGI("AAudio Try to reopen %u hz %u bit chan %u %s samples %u",
          device->spec.freq, SDL_AUDIO_BITSIZE(device->spec.format),
diff --git a/src/core/android/SDL_android.c b/src/core/android/SDL_android.c
index 60620d8..20aaafb 100644
--- a/src/core/android/SDL_android.c
+++ b/src/core/android/SDL_android.c
@@ -48,6 +48,7 @@
 #include <pthread.h>
 #include <sys/types.h>
 #include <unistd.h>
+#include <stdlib.h>  /* for getenv() */
 #include <dlfcn.h>
 
 #define SDL_JAVA_PREFIX                               org_libsdl_app
@@ -74,6 +75,12 @@ JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeRunMain)(
     JNIEnv *env, jclass cls,
     jstring library, jstring function, jobject array);
 
+JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvCurrent)(
+        JNIEnv *env, jclass cls);
+
+JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvNull)(
+        JNIEnv *env, jclass cls);
+
 JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeDropFile)(
     JNIEnv *env, jclass jcls,
     jstring filename);
@@ -118,6 +125,34 @@ JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouse)(
     JNIEnv *env, jclass jcls,
     jint button, jint action, jfloat x, jfloat y, jboolean relative);
 
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseDirect)(
+    JNIEnv *env, jclass jcls,
+    jint button, jint action, jfloat x, jfloat y, jboolean relative);
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseButton)(
+    JNIEnv *env, jclass jcls,
+    jint sdlButton, jint pressed, jfloat x, jfloat y);
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseButtonOnly)(
+    JNIEnv *env, jclass jcls,
+    jint sdlButton, jint pressed);
+
+JNIEXPORT jint JNICALL SDL_JAVA_INTERFACE(nativeGetMouseStateX)(
+    JNIEnv *env, jclass jcls);
+
+JNIEXPORT jint JNICALL SDL_JAVA_INTERFACE(nativeGetMouseStateY)(
+    JNIEnv *env, jclass jcls);
+
+/* 虚拟控件触摸点管理 */
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeConsumeFingerTouch)(
+    JNIEnv *env, jclass jcls, jint fingerId);
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeReleaseFingerTouch)(
+    JNIEnv *env, jclass jcls, jint fingerId);
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeClearConsumedFingers)(
+    JNIEnv *env, jclass jcls);
+
 JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeAccel)(
     JNIEnv *env, jclass jcls,
     jfloat x, jfloat y, jfloat z);
@@ -174,6 +209,8 @@ static JNINativeMethod SDLActivity_tab[] = {
     { "nativeGetVersion", "()Ljava/lang/String;", SDL_JAVA_INTERFACE(nativeGetVersion) },
     { "nativeSetupJNI", "()I", SDL_JAVA_INTERFACE(nativeSetupJNI) },
     { "nativeRunMain", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)I", SDL_JAVA_INTERFACE(nativeRunMain) },
+    {"nativeAndroidJNISetEnvCurrent", "()I", SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvCurrent)},
+    {"nativeAndroidJNISetEnvNull", "()I", SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvNull)},
     { "onNativeDropFile", "(Ljava/lang/String;)V", SDL_JAVA_INTERFACE(onNativeDropFile) },
     { "nativeSetScreenResolution", "(IIIIF)V", SDL_JAVA_INTERFACE(nativeSetScreenResolution) },
     { "onNativeResize", "()V", SDL_JAVA_INTERFACE(onNativeResize) },
@@ -186,6 +223,14 @@ static JNINativeMethod SDLActivity_tab[] = {
     { "onNativeKeyboardFocusLost", "()V", SDL_JAVA_INTERFACE(onNativeKeyboardFocusLost) },
     { "onNativeTouch", "(IIIFFF)V", SDL_JAVA_INTERFACE(onNativeTouch) },
     { "onNativeMouse", "(IIFFZ)V", SDL_JAVA_INTERFACE(onNativeMouse) },
+    { "onNativeMouseDirect", "(IIFFZ)V", SDL_JAVA_INTERFACE(onNativeMouseDirect) },
+    { "onNativeMouseButton", "(IIFF)V", SDL_JAVA_INTERFACE(onNativeMouseButton) },
+    { "onNativeMouseButtonOnly", "(II)V", SDL_JAVA_INTERFACE(onNativeMouseButtonOnly) },
+    { "nativeGetMouseStateX", "()I", SDL_JAVA_INTERFACE(nativeGetMouseStateX) },
+    { "nativeGetMouseStateY", "()I", SDL_JAVA_INTERFACE(nativeGetMouseStateY) },
+    { "nativeConsumeFingerTouch", "(I)V", SDL_JAVA_INTERFACE(nativeConsumeFingerTouch) },
+    { "nativeReleaseFingerTouch", "(I)V", SDL_JAVA_INTERFACE(nativeReleaseFingerTouch) },
+    { "nativeClearConsumedFingers", "()V", SDL_JAVA_INTERFACE(nativeClearConsumedFingers) },
     { "onNativeAccel", "(FFF)V", SDL_JAVA_INTERFACE(onNativeAccel) },
     { "onNativeClipboardChanged", "()V", SDL_JAVA_INTERFACE(onNativeClipboardChanged) },
     { "nativeLowMemory", "()V", SDL_JAVA_INTERFACE(nativeLowMemory) },
@@ -258,7 +303,7 @@ JNIEXPORT void JNICALL SDL_JAVA_CONTROLLER_INTERFACE(onNativeHat)(
 JNIEXPORT jint JNICALL SDL_JAVA_CONTROLLER_INTERFACE(nativeAddJoystick)(
     JNIEnv *env, jclass jcls,
     jint device_id, jstring device_name, jstring device_desc, jint vendor_id, jint product_id,
-    jboolean is_accelerometer, jint button_mask, jint naxes, jint axis_mask, jint nhats, jint nballs);
+    jboolean is_accelerometer, jint button_mask, jint naxes, jint axis_mask, jint nhats, jint nballs, jboolean can_rumble);
 
 JNIEXPORT jint JNICALL SDL_JAVA_CONTROLLER_INTERFACE(nativeRemoveJoystick)(
     JNIEnv *env, jclass jcls,
@@ -278,7 +323,7 @@ static JNINativeMethod SDLControllerManager_tab[] = {
     { "onNativePadUp", "(II)I", SDL_JAVA_CONTROLLER_INTERFACE(onNativePadUp) },
     { "onNativeJoy", "(IIF)V", SDL_JAVA_CONTROLLER_INTERFACE(onNativeJoy) },
     { "onNativeHat", "(IIII)V", SDL_JAVA_CONTROLLER_INTERFACE(onNativeHat) },
-    { "nativeAddJoystick", "(ILjava/lang/String;Ljava/lang/String;IIZIIIII)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeAddJoystick) },
+    { "nativeAddJoystick", "(ILjava/lang/String;Ljava/lang/String;IIZIIIIIZ)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeAddJoystick) },
     { "nativeRemoveJoystick", "(I)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeRemoveJoystick) },
     { "nativeAddHaptic", "(ILjava/lang/String;)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeAddHaptic) },
     { "nativeRemoveHaptic", "(I)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeRemoveHaptic) }
@@ -361,6 +406,7 @@ static jclass mControllerManagerClass;
 static jmethodID midPollInputDevices;
 static jmethodID midPollHapticDevices;
 static jmethodID midHapticRun;
+static jmethodID midHapticRumble;
 static jmethodID midHapticStop;
 
 /* Accelerometer data storage */
@@ -448,6 +494,8 @@ JNIEnv *Android_JNI_GetEnv(void)
 }
 
 /* Set up an external thread for using JNI with Android_JNI_GetEnv() */
+/* EXPORTED: Used by glibc_bridge to setup JNI before Box64 execution */
+__attribute__((visibility("default")))
 int Android_JNI_SetupThread(void)
 {
     JNIEnv *env;
@@ -721,10 +769,12 @@ JNIEXPORT void JNICALL SDL_JAVA_CONTROLLER_INTERFACE(nativeSetupJNI)(JNIEnv *env
                                                      "pollHapticDevices", "()V");
     midHapticRun = (*env)->GetStaticMethodID(env, mControllerManagerClass,
                                              "hapticRun", "(IFI)V");
+    midHapticRumble = (*env)->GetStaticMethodID(env, mControllerManagerClass,
+                                                "hapticRumble", "(IFFI)V");
     midHapticStop = (*env)->GetStaticMethodID(env, mControllerManagerClass,
                                               "hapticStop", "(I)V");
 
-    if (!midPollInputDevices || !midPollHapticDevices || !midHapticRun || !midHapticStop) {
+    if (!midPollInputDevices || !midPollHapticDevices || !midHapticRun || !midHapticRumble || !midHapticStop) {
         __android_log_print(ANDROID_LOG_WARN, "SDL", "Missing some Java callbacks, do you have the latest version of SDLControllerManager.java?");
     }
 
@@ -830,6 +880,14 @@ JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeRunMain)(JNIEnv *env, jclass cls,
     return status;
 }
 
+JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvCurrent)(JNIEnv *env, jclass cls) {
+    return Android_JNI_SetEnv(env);
+}
+
+JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvNull)(JNIEnv *env, jclass cls) {
+    return Android_JNI_SetEnv(NULL);
+}
+
 /* Drop file */
 JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeDropFile)(
     JNIEnv *env, jclass jcls,
@@ -994,13 +1052,13 @@ JNIEXPORT jint JNICALL SDL_JAVA_CONTROLLER_INTERFACE(nativeAddJoystick)(
     JNIEnv *env, jclass jcls,
     jint device_id, jstring device_name, jstring device_desc,
     jint vendor_id, jint product_id, jboolean is_accelerometer,
-    jint button_mask, jint naxes, jint axis_mask, jint nhats, jint nballs)
+    jint button_mask, jint naxes, jint axis_mask, jint nhats, jint nballs, jboolean can_rumble)
 {
     int retval;
     const char *name = (*env)->GetStringUTFChars(env, device_name, NULL);
     const char *desc = (*env)->GetStringUTFChars(env, device_desc, NULL);
 
-    retval = Android_AddJoystick(device_id, name, desc, vendor_id, product_id, is_accelerometer ? SDL_TRUE : SDL_FALSE, button_mask, naxes, axis_mask, nhats, nballs);
+    retval = Android_AddJoystick(device_id, name, desc, vendor_id, product_id, is_accelerometer ? SDL_TRUE : SDL_FALSE, button_mask, naxes, axis_mask, nhats, nballs, can_rumble);
 
     (*env)->ReleaseStringUTFChars(env, device_name, name);
     (*env)->ReleaseStringUTFChars(env, device_desc, desc);
@@ -1176,6 +1234,84 @@ JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouse)(
     SDL_UnlockMutex(Android_ActivityMutex);
 }
 
+/* Mouse Direct - same as onNativeMouse but without state check */
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseDirect)(
+    JNIEnv *env, jclass jcls,
+    jint button, jint action, jfloat x, jfloat y, jboolean relative)
+{
+    SDL_LockMutex(Android_ActivityMutex);
+
+    Android_OnMouseDirect(Android_Window, button, action, x, y, relative);
+
+    SDL_UnlockMutex(Android_ActivityMutex);
+}
+
+/* Direct mouse button - bypasses state tracking for virtual controls */
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseButton)(
+    JNIEnv *env, jclass jcls,
+    jint sdlButton, jint pressed, jfloat x, jfloat y)
+{
+    SDL_LockMutex(Android_ActivityMutex);
+
+    Android_OnMouseButtonDirect(Android_Window, sdlButton, pressed, x, y);
+
+    SDL_UnlockMutex(Android_ActivityMutex);
+}
+
+/* Mouse button only - no cursor movement, for virtual button controls */
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseButtonOnly)(
+    JNIEnv *env, jclass jcls,
+    jint sdlButton, jint pressed)
+{
+    SDL_LockMutex(Android_ActivityMutex);
+
+    Android_OnMouseButtonOnly(Android_Window, sdlButton, pressed);
+
+    SDL_UnlockMutex(Android_ActivityMutex);
+}
+
+/* Get current mouse X position */
+JNIEXPORT jint JNICALL SDL_JAVA_INTERFACE(nativeGetMouseStateX)(
+    JNIEnv *env, jclass jcls)
+{
+    int x = 0;
+    SDL_GetMouseState(&x, NULL);
+    return (jint)x;
+}
+
+/* Get current mouse Y position */
+JNIEXPORT jint JNICALL SDL_JAVA_INTERFACE(nativeGetMouseStateY)(
+    JNIEnv *env, jclass jcls)
+{
+    int y = 0;
+    SDL_GetMouseState(NULL, &y);
+    return (jint)y;
+}
+
+/* 外部函数声明（在 SDL_touch.c 中定义） */
+extern void SDL_ConsumeFingerTouch(int fingerId);
+extern void SDL_ReleaseFingerTouch(int fingerId);
+extern void SDL_ClearConsumedFingers(void);
+
+/* 虚拟控件触摸点管理 - 被标记的触摸点不会转换为鼠标事件 */
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeConsumeFingerTouch)(
+    JNIEnv *env, jclass jcls, jint fingerId)
+{
+    SDL_ConsumeFingerTouch((int)fingerId);
+}
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeReleaseFingerTouch)(
+    JNIEnv *env, jclass jcls, jint fingerId)
+{
+    SDL_ReleaseFingerTouch((int)fingerId);
+}
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeClearConsumedFingers)(
+    JNIEnv *env, jclass jcls)
+{
+    SDL_ClearConsumedFingers();
+}
+
 /* Accelerometer */
 JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeAccel)(
     JNIEnv *env, jclass jcls,
@@ -1406,10 +1542,35 @@ ANativeWindow *Android_JNI_GetNativeWindow(void)
     jobject s;
     JNIEnv *env = Android_JNI_GetEnv();
 
+    __android_log_print(ANDROID_LOG_INFO, "SDL_JNI", "Android_JNI_GetNativeWindow called");
+    __android_log_print(ANDROID_LOG_INFO, "SDL_JNI", "  env=%p, mActivityClass=%p, midGetNativeSurface=%p",
+                        env, mActivityClass, midGetNativeSurface);
+
+    if (!env) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  ERROR: JNIEnv is NULL!");
+        return NULL;
+    }
+
+    if (!mActivityClass) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  ERROR: mActivityClass is NULL! nativeSetupJNI not called?");
+        return NULL;
+    }
+
+    if (!midGetNativeSurface) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  ERROR: midGetNativeSurface is NULL!");
+        return NULL;
+    }
+
     s = (*env)->CallStaticObjectMethod(env, mActivityClass, midGetNativeSurface);
+    __android_log_print(ANDROID_LOG_INFO, "SDL_JNI", "  getNativeSurface() returned: %p", s);
+
     if (s) {
         anw = ANativeWindow_fromSurface(env, s);
+        __android_log_print(ANDROID_LOG_INFO, "SDL_JNI", "  ANativeWindow_fromSurface returned: %p", anw);
         (*env)->DeleteLocalRef(env, s);
+    } else {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  ERROR: getNativeSurface() returned NULL!");
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  This means SDLActivity.mSurface is null or Surface not ready");
     }
 
     return anw;
@@ -2155,6 +2316,7 @@ int Android_JNI_GetPowerInfo(int *plugged, int *charged, int *battery, int *seco
 /* Add all touch devices */
 void Android_JNI_InitTouch()
 {
+
     JNIEnv *env = Android_JNI_GetEnv();
     (*env)->CallStaticVoidMethod(env, mActivityClass, midInitTouch);
 }
@@ -2177,6 +2339,12 @@ void Android_JNI_HapticRun(int device_id, float intensity, int length)
     (*env)->CallStaticVoidMethod(env, mControllerManagerClass, midHapticRun, device_id, intensity, length);
 }
 
+void Android_JNI_HapticRumble(int device_id, float low_frequency_intensity, float high_frequency_intensity, int length)
+{
+    JNIEnv *env = Android_JNI_GetEnv();
+    (*env)->CallStaticVoidMethod(env, mControllerManagerClass, midHapticRumble, device_id, low_frequency_intensity, high_frequency_intensity, length);
+}
+
 void Android_JNI_HapticStop(int device_id)
 {
     JNIEnv *env = Android_JNI_GetEnv();
@@ -2550,6 +2718,14 @@ void Android_JNI_GetManifestEnvironmentVariables(void)
 
     if (!bHasEnvironmentVariables) {
         JNIEnv *env = Android_JNI_GetEnv();
+        /* Box64 fix: Check if JNIEnv is valid before using it
+         * When running from Box64 emulated threads, the JNI environment may not be
+         * properly attached, which would cause CallStaticBooleanMethod to crash. */
+        if (!env) {
+            __android_log_print(ANDROID_LOG_WARN, "SDL",
+                "Android_JNI_GetManifestEnvironmentVariables: JNIEnv is NULL, skipping (Box64 thread?)");
+            return;
+        }
         SDL_bool ret = (*env)->CallStaticBooleanMethod(env, mActivityClass, midGetManifestEnvironmentVariables);
         if (ret) {
             bHasEnvironmentVariables = SDL_TRUE;
diff --git a/src/core/android/SDL_android.h b/src/core/android/SDL_android.h
index 20d1fc5..2d8d0fa 100644
--- a/src/core/android/SDL_android.h
+++ b/src/core/android/SDL_android.h
@@ -91,6 +91,7 @@ void Android_JNI_PollInputDevices(void);
 /* Haptic support */
 void Android_JNI_PollHapticDevices(void);
 void Android_JNI_HapticRun(int device_id, float intensity, int length);
+void Android_JNI_HapticRumble(int device_id, float low_frequency_intensity, float high_frequency_intensity, int length);
 void Android_JNI_HapticStop(int device_id);
 
 /* Video */
diff --git a/src/events/SDL_mouse.c b/src/events/SDL_mouse.c
index 431354f..3105935 100644
--- a/src/events/SDL_mouse.c
+++ b/src/events/SDL_mouse.c
@@ -44,6 +44,15 @@ static SDL_Mouse SDL_mouse;
 /* for mapping mouse events to touch */
 static SDL_bool track_mouse_down = SDL_FALSE;
 
+/* Virtual mouse range limit (for game controls) */
+static SDL_bool g_vm_range_enabled = SDL_FALSE;
+static int g_vm_screen_width = 1920;
+static int g_vm_screen_height = 1080;
+static float g_vm_range_left = 1.0f;
+static float g_vm_range_top = 1.0f;
+static float g_vm_range_right = 1.0f;
+static float g_vm_range_bottom = 1.0f;
+
 static int SDL_PrivateSendMouseMotion(SDL_Window *window, SDL_MouseID mouseID, int relative, int x, int y);
 
 static void SDLCALL SDL_MouseDoubleClickTimeChanged(void *userdata, const char *name, const char *oldValue, const char *hint)
@@ -782,7 +791,17 @@ static int SDL_PrivateSendMouseButton(SDL_Window *window, SDL_MouseID mouseID, U
         SDL_UpdateMouseFocus(window, mouse->x, mouse->y, buttonstate, SDL_TRUE);
     }
 
-    if (buttonstate == source->buttonstate) {
+    /* RALCore: For multi-touch mouse emulation, skip state check when SDL_TOUCH_MOUSE_MULTITOUCH=1
+     * This allows multiple simultaneous touch points to each generate mouse events */
+    SDL_bool skip_state_check = SDL_FALSE;
+    if (mouseID == SDL_TOUCH_MOUSEID) {
+        const char* multitouch_hint = SDL_GetHint("SDL_TOUCH_MOUSE_MULTITOUCH");
+        if (multitouch_hint && SDL_strcmp(multitouch_hint, "1") == 0) {
+            skip_state_check = SDL_TRUE;
+        }
+    }
+
+    if (!skip_state_check && buttonstate == source->buttonstate) {
         /* Ignore this event, no state change */
         return 0;
     }
@@ -1501,4 +1520,48 @@ int SDL_ShowCursor(int toggle)
     return shown;
 }
 
+/* Virtual mouse range limit functions (for game controls) - exported */
+DECLSPEC void SDLCALL SDL_SetVirtualMouseRangeEnabled(SDL_bool enabled)
+{
+    g_vm_range_enabled = enabled;
+}
+
+DECLSPEC void SDLCALL SDL_SetVirtualMouseScreenSize(int width, int height)
+{
+    g_vm_screen_width = width > 0 ? width : 1920;
+    g_vm_screen_height = height > 0 ? height : 1080;
+}
+
+DECLSPEC void SDLCALL SDL_SetVirtualMouseRange(float left, float top, float right, float bottom)
+{
+    g_vm_range_left = left;
+    g_vm_range_top = top;
+    g_vm_range_right = right;
+    g_vm_range_bottom = bottom;
+}
+
+/* Apply range limit to coordinates - exported for virtual mouse usage */
+DECLSPEC void SDLCALL SDL_ApplyVirtualMouseRangeLimit(int *mouseX, int *mouseY)
+{
+    float centerX, centerY;
+    int minX, maxX, minY, maxY;
+    
+    if (!g_vm_range_enabled) {
+        return;
+    }
+    
+    centerX = g_vm_screen_width * 0.5f;
+    centerY = g_vm_screen_height * 0.5f;
+    
+    minX = (int)(centerX - (g_vm_range_left * centerX));
+    maxX = (int)(centerX + (g_vm_range_right * centerX));
+    minY = (int)(centerY - (g_vm_range_top * centerY));
+    maxY = (int)(centerY + (g_vm_range_bottom * centerY));
+    
+    if (*mouseX < minX) *mouseX = minX;
+    if (*mouseX > maxX) *mouseX = maxX;
+    if (*mouseY < minY) *mouseY = minY;
+    if (*mouseY > maxY) *mouseY = maxY;
+}
+
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/events/SDL_touch.c b/src/events/SDL_touch.c
index b5ec77b..ef50f2c 100644
--- a/src/events/SDL_touch.c
+++ b/src/events/SDL_touch.c
@@ -23,9 +23,15 @@
 /* General touch handling code for SDL */
 
 #include "SDL_events.h"
+#include "SDL_hints.h"
+#include "SDL_timer.h"
 #include "SDL_events_c.h"
 #include "../video/SDL_sysvideo.h"
 
+#ifdef __ANDROID__
+#include <android/log.h>
+#endif
+
 static int SDL_num_touch = 0;
 static SDL_Touch **SDL_touchDevices = NULL;
 
@@ -37,6 +43,104 @@ static SDL_Touch **SDL_touchDevices = NULL;
 static SDL_bool finger_touching = SDL_FALSE;
 static SDL_FingerID track_fingerid;
 static SDL_TouchID track_touchid;
+
+/* Multi-touch support for mouse emulation (RALCore extension)
+ * 
+ * When SDL_TOUCH_MOUSE_MULTITOUCH=1:
+ * - Each finger independently sends mouse button events
+ * - SDL_mouse.c's state check is bypassed to allow duplicate button events
+ * - The most recently touched finger controls mouse cursor movement
+ */
+#define MAX_TRACKED_FINGERS 10
+static int multitouch_finger_count = 0;
+static SDL_FingerID multitouch_fingers[MAX_TRACKED_FINGERS];
+static float multitouch_finger_x[MAX_TRACKED_FINGERS];
+static float multitouch_finger_y[MAX_TRACKED_FINGERS];
+static SDL_bool multitouch_enabled = SDL_FALSE;
+static SDL_FingerID multitouch_active_finger = 0;
+
+/* 被虚拟控件占用的触摸点（不参与触屏转鼠标） */
+#define MAX_CONSUMED_FINGERS 10
+static int consumed_finger_count = 0;
+static int consumed_fingers[MAX_CONSUMED_FINGERS];
+
+/* 检查触摸点是否被虚拟控件占用 */
+static SDL_bool SDL_IsFingerConsumed(int fingerId) {
+    for (int i = 0; i < consumed_finger_count; i++) {
+        if (consumed_fingers[i] == fingerId) return SDL_TRUE;
+    }
+    return SDL_FALSE;
+}
+
+/* 标记触摸点被虚拟控件占用（由 Java 层调用） */
+void SDL_ConsumeFingerTouch(int fingerId) {
+    if (consumed_finger_count >= MAX_CONSUMED_FINGERS) return;
+    if (SDL_IsFingerConsumed(fingerId)) return;
+    consumed_fingers[consumed_finger_count++] = fingerId;
+#ifdef __ANDROID__
+    /* Reduced logging */
+    #if 0
+    __android_log_print(ANDROID_LOG_VERBOSE, "SDLTouch", "Finger %d consumed by virtual control", fingerId);
+    #endif
+#endif
+}
+
+/* 释放被虚拟控件占用的触摸点（由 Java 层调用） */
+void SDL_ReleaseFingerTouch(int fingerId) {
+    for (int i = 0; i < consumed_finger_count; i++) {
+        if (consumed_fingers[i] == fingerId) {
+            for (int j = i; j < consumed_finger_count - 1; j++) {
+                consumed_fingers[j] = consumed_fingers[j + 1];
+            }
+            consumed_finger_count--;
+#ifdef __ANDROID__
+            __android_log_print(ANDROID_LOG_INFO, "SDLTouch", "Finger %d released", fingerId);
+#endif
+            return;
+        }
+    }
+}
+
+/* 清除所有占用的触摸点 */
+void SDL_ClearConsumedFingers(void) {
+    consumed_finger_count = 0;
+#ifdef __ANDROID__
+    __android_log_print(ANDROID_LOG_INFO, "SDLTouch", "All consumed fingers cleared");
+#endif
+}
+
+static int SDL_FindMultitouchFinger(SDL_FingerID fingerid) {
+    for (int i = 0; i < multitouch_finger_count; i++) {
+        if (multitouch_fingers[i] == fingerid) return i;
+    }
+    return -1;
+}
+
+static void SDL_AddMultitouchFinger(SDL_FingerID fingerid, float x, float y) {
+    if (multitouch_finger_count >= MAX_TRACKED_FINGERS) return;
+    multitouch_fingers[multitouch_finger_count] = fingerid;
+    multitouch_finger_x[multitouch_finger_count] = x;
+    multitouch_finger_y[multitouch_finger_count] = y;
+    multitouch_finger_count++;
+}
+
+static void SDL_RemoveMultitouchFinger(SDL_FingerID fingerid) {
+    int idx = SDL_FindMultitouchFinger(fingerid);
+    if (idx < 0) return;
+    for (int i = idx; i < multitouch_finger_count - 1; i++) {
+        multitouch_fingers[i] = multitouch_fingers[i + 1];
+        multitouch_finger_x[i] = multitouch_finger_x[i + 1];
+        multitouch_finger_y[i] = multitouch_finger_y[i + 1];
+    }
+    multitouch_finger_count--;
+}
+
+static void SDL_UpdateMultitouchFinger(SDL_FingerID fingerid, float x, float y) {
+    int idx = SDL_FindMultitouchFinger(fingerid);
+    if (idx < 0) return;
+    multitouch_finger_x[idx] = x;
+    multitouch_finger_y[idx] = y;
+}
 #endif
 
 /* Public functions */
@@ -248,51 +352,157 @@ int SDL_SendTouch(SDL_TouchID id, SDL_FingerID fingerid, SDL_Window *window,
     mouse = SDL_GetMouse();
 
 #if SYNTHESIZE_TOUCH_TO_MOUSE
+    /* 检查此触摸点是否被虚拟控件占用（如虚拟摇杆）*/
+    SDL_bool isConsumed = SDL_IsFingerConsumed((int)fingerid);
+#ifdef __ANDROID__
+    /* Reduced logging */
+    #if 0
+    if (isConsumed) {
+        __android_log_print(ANDROID_LOG_VERBOSE, "SDLTouchMouse", 
+            "Finger %d is consumed by virtual control, skipping mouse events", (int)fingerid);
+    }
+    #endif
+#endif
+    
+    /* Check for multitouch mode: SDL_TOUCH_MOUSE_MULTITOUCH=1 enables multi-finger gestures */
+    {
+        const char* multitouch_hint = SDL_GetHint("SDL_TOUCH_MOUSE_MULTITOUCH");
+        multitouch_enabled = (multitouch_hint && SDL_strcmp(multitouch_hint, "1") == 0);
+    }
+    
     /* SDL_HINT_TOUCH_MOUSE_EVENTS: controlling whether touch events should generate synthetic mouse events */
     /* SDL_HINT_VITA_TOUCH_MOUSE_DEVICE: controlling which touchpad should generate synthetic mouse events, PSVita-only */
+    /* 只有未被虚拟控件占用的触摸点才会生成鼠标事件 */
     {
 #if defined(__vita__)
-        if (mouse->touch_mouse_events && ((mouse->vita_touch_mouse_device == id) || (mouse->vita_touch_mouse_device == 2))) {
+        if (mouse->touch_mouse_events && !isConsumed && ((mouse->vita_touch_mouse_device == id) || (mouse->vita_touch_mouse_device == 2))) {
 #else
-        if (mouse->touch_mouse_events) {
+        if (mouse->touch_mouse_events && !isConsumed) {
 #endif
             /* FIXME: maybe we should only restrict to a few SDL_TouchDeviceType */
             if (id != SDL_MOUSE_TOUCHID) {
                 if (window) {
-                    if (down) {
-                        if (finger_touching == SDL_FALSE) {
+                    if (multitouch_enabled) {
+                        /* Multi-touch mode: each finger sends independent mouse events
+                         * SDL_mouse.c will skip state checking when multitouch is enabled
+                         */
+                        if (down) {
                             int pos_x = (int)(x * (float)window->w);
                             int pos_y = (int)(y * (float)window->h);
-                            if (pos_x < 0) {
-                                pos_x = 0;
+                            if (pos_x < 0) pos_x = 0;
+                            if (pos_x > window->w - 1) pos_x = window->w - 1;
+                            if (pos_y < 0) pos_y = 0;
+                            if (pos_y > window->h - 1) pos_y = window->h - 1;
+                            
+                            SDL_AddMultitouchFinger(fingerid, x, y);
+                            
+                            /* This finger becomes the active one (controls mouse movement) */
+                            multitouch_active_finger = fingerid;
+                            finger_touching = SDL_TRUE;
+                            track_touchid = id;
+                            track_fingerid = fingerid;
+                            
+                            /* Send mouse move and button press - state check bypassed in SDL_mouse.c */
+                            SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
+                            SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
+                        } else {
+                            /* Finger up */
+                            int finger_idx = SDL_FindMultitouchFinger(fingerid);
+                            SDL_bool is_active = (fingerid == multitouch_active_finger);
+                            
+                            /* Send release at this finger's position */
+                            if (finger_idx >= 0) {
+                                int pos_x = (int)(multitouch_finger_x[finger_idx] * (float)window->w);
+                                int pos_y = (int)(multitouch_finger_y[finger_idx] * (float)window->h);
+                                if (pos_x < 0) pos_x = 0;
+                                if (pos_x > window->w - 1) pos_x = window->w - 1;
+                                if (pos_y < 0) pos_y = 0;
+                                if (pos_y > window->h - 1) pos_y = window->h - 1;
+                                SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
+                                SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_RELEASED, SDL_BUTTON_LEFT);
                             }
-                            if (pos_x > window->w - 1) {
-                                pos_x = window->w - 1;
+                            
+                            SDL_RemoveMultitouchFinger(fingerid);
+                            
+                            if (is_active && multitouch_finger_count > 0) {
+                                /* Transfer active finger */
+                                multitouch_active_finger = multitouch_fingers[0];
+                                track_fingerid = multitouch_fingers[0];
+                            } else if (multitouch_finger_count == 0) {
+                                finger_touching = SDL_FALSE;
                             }
-                            if (pos_y < 0) {
-                                pos_y = 0;
+                        }
+                    } else {
+                        /* Original single-touch behavior */
+#ifdef __ANDROID__
+                        __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                            "Single-touch mode: down=%d finger_touching=%d finger=%lld track_finger=%lld",
+                            down, finger_touching, (long long)fingerid, (long long)track_fingerid);
+#endif
+                        if (down) {
+                            if (finger_touching == SDL_FALSE) {
+                                int pos_x = (int)(x * (float)window->w);
+                                int pos_y = (int)(y * (float)window->h);
+                                if (pos_x < 0) {
+                                    pos_x = 0;
+                                }
+                                if (pos_x > window->w - 1) {
+                                    pos_x = window->w - 1;
+                                }
+                                if (pos_y < 0) {
+                                    pos_y = 0;
+                                }
+                                if (pos_y > window->h - 1) {
+                                    pos_y = window->h - 1;
+                                }
+#ifdef __ANDROID__
+                                __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                                    "  -> Sending mouse DOWN at (%d,%d)", pos_x, pos_y);
+#endif
+                                SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
+                                SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
+                            } else {
+#ifdef __ANDROID__
+                                __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                                    "  -> SKIPPED (finger_touching=TRUE)");
+#endif
                             }
-                            if (pos_y > window->h - 1) {
-                                pos_y = window->h - 1;
+                        } else {
+                            if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
+#ifdef __ANDROID__
+                                __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                                    "  -> Sending mouse UP");
+#endif
+                                SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_RELEASED, SDL_BUTTON_LEFT);
                             }
-                            SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
-                            SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
+                        }
+                    }
+                }
+                
+                /* Track single finger state (for non-multitouch mode) */
+                /* 只有未被虚拟控件占用的触摸点才会更新跟踪状态 */
+                if (!multitouch_enabled && !isConsumed) {
+                    if (down) {
+                        if (finger_touching == SDL_FALSE) {
+                            finger_touching = SDL_TRUE;
+                            track_touchid = id;
+                            track_fingerid = fingerid;
                         }
                     } else {
                         if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
-                            SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_RELEASED, SDL_BUTTON_LEFT);
+                            finger_touching = SDL_FALSE;
                         }
                     }
                 }
-                if (down) {
-                    if (finger_touching == SDL_FALSE) {
-                        finger_touching = SDL_TRUE;
-                        track_touchid = id;
-                        track_fingerid = fingerid;
-                    }
-                } else {
+                /* 被占用的触摸点释放时，也需要检查是否需要重置状态 */
+                else if (!multitouch_enabled && isConsumed && !down) {
+                    /* 如果被占用的触摸点释放，且它是当前跟踪的触摸点，重置状态 */
                     if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
                         finger_touching = SDL_FALSE;
+#ifdef __ANDROID__
+                        __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                            "Consumed finger released, resetting finger_touching state");
+#endif
                     }
                 }
             }
@@ -382,22 +592,39 @@ int SDL_SendTouchMotion(SDL_TouchID id, SDL_FingerID fingerid, SDL_Window *windo
         if (mouse->touch_mouse_events) {
             if (id != SDL_MOUSE_TOUCHID) {
                 if (window) {
-                    if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
-                        int pos_x = (int)(x * (float)window->w);
-                        int pos_y = (int)(y * (float)window->h);
-                        if (pos_x < 0) {
-                            pos_x = 0;
-                        }
-                        if (pos_x > window->w - 1) {
-                            pos_x = window->w - 1;
-                        }
-                        if (pos_y < 0) {
-                            pos_y = 0;
+                    if (multitouch_enabled) {
+                        /* Multi-touch mode: update finger position */
+                        SDL_UpdateMultitouchFinger(fingerid, x, y);
+                        
+                        /* Only active finger controls cursor movement */
+                        if (fingerid == multitouch_active_finger && finger_touching == SDL_TRUE) {
+                            int pos_x = (int)(x * (float)window->w);
+                            int pos_y = (int)(y * (float)window->h);
+                            if (pos_x < 0) pos_x = 0;
+                            if (pos_x > window->w - 1) pos_x = window->w - 1;
+                            if (pos_y < 0) pos_y = 0;
+                            if (pos_y > window->h - 1) pos_y = window->h - 1;
+                            SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
                         }
-                        if (pos_y > window->h - 1) {
-                            pos_y = window->h - 1;
+                    } else {
+                        /* Original single-touch behavior */
+                        if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
+                            int pos_x = (int)(x * (float)window->w);
+                            int pos_y = (int)(y * (float)window->h);
+                            if (pos_x < 0) {
+                                pos_x = 0;
+                            }
+                            if (pos_x > window->w - 1) {
+                                pos_x = window->w - 1;
+                            }
+                            if (pos_y < 0) {
+                                pos_y = 0;
+                            }
+                            if (pos_y > window->h - 1) {
+                                pos_y = window->h - 1;
+                            }
+                            SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
                         }
-                        SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
                     }
                 }
             }
@@ -497,3 +724,4 @@ void SDL_TouchQuit(void)
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
+
diff --git a/src/joystick/android/SDL_sysjoystick.c b/src/joystick/android/SDL_sysjoystick.c
index c29f738..850edc7 100644
--- a/src/joystick/android/SDL_sysjoystick.c
+++ b/src/joystick/android/SDL_sysjoystick.c
@@ -304,7 +304,7 @@ int Android_OnHat(int device_id, int hat_id, int x, int y)
     return -1;
 }
 
-int Android_AddJoystick(int device_id, const char *name, const char *desc, int vendor_id, int product_id, SDL_bool is_accelerometer, int button_mask, int naxes, int axis_mask, int nhats, int nballs)
+int Android_AddJoystick(int device_id, const char *name, const char *desc, int vendor_id, int product_id, SDL_bool is_accelerometer, int button_mask, int naxes, int axis_mask, int nhats, int nballs, SDL_bool can_rumble)
 {
     SDL_joylist_item *item;
     SDL_JoystickGUID guid;
@@ -379,6 +379,7 @@ int Android_AddJoystick(int device_id, const char *name, const char *desc, int v
     }
     item->naxes = naxes;
     item->nhats = nhats;
+    item->can_rumble = can_rumble;
     item->nballs = nballs;
     item->device_instance = SDL_GetNextJoystickInstanceID();
     if (!SDL_joylist_tail) {
@@ -468,7 +469,7 @@ static int ANDROID_JoystickInit(void)
 
     if (SDL_GetHintBoolean(SDL_HINT_ACCELEROMETER_AS_JOYSTICK, SDL_TRUE)) {
         /* Default behavior, accelerometer as joystick */
-        Android_AddJoystick(ANDROID_ACCELEROMETER_DEVICE_ID, ANDROID_ACCELEROMETER_NAME, ANDROID_ACCELEROMETER_NAME, 0, 0, SDL_TRUE, 0, 3, 0x0003, 0, 0);
+        Android_AddJoystick(ANDROID_ACCELEROMETER_DEVICE_ID, ANDROID_ACCELEROMETER_NAME, ANDROID_ACCELEROMETER_NAME, 0, 0, SDL_TRUE, 0, 3, 0x0003, 0, 0, SDL_FALSE);
     }
     return 0;
 }
@@ -591,7 +592,18 @@ static int ANDROID_JoystickOpen(SDL_Joystick *joystick, int device_index)
 
 static int ANDROID_JoystickRumble(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble)
 {
-    return SDL_Unsupported();
+    SDL_joylist_item *item = (SDL_joylist_item *)joystick->hwdata;
+    if (!item) {
+        return SDL_SetError("Rumble failed, device disconnected");
+    }
+    if (!item->can_rumble) {
+        return SDL_Unsupported();
+    }
+
+    float low_frequency_intensity = (float)low_frequency_rumble / SDL_MAX_UINT16;
+    float high_frequency_intensity = (float)high_frequency_rumble / SDL_MAX_UINT16;
+    Android_JNI_HapticRumble(item->device_id, low_frequency_intensity, high_frequency_intensity, 5000);
+    return 0;
 }
 
 static int ANDROID_JoystickRumbleTriggers(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble)
diff --git a/src/joystick/android/SDL_sysjoystick_c.h b/src/joystick/android/SDL_sysjoystick_c.h
index 189bcf4..1e5c44e 100644
--- a/src/joystick/android/SDL_sysjoystick_c.h
+++ b/src/joystick/android/SDL_sysjoystick_c.h
@@ -32,7 +32,7 @@ extern int Android_OnPadDown(int device_id, int keycode);
 extern int Android_OnPadUp(int device_id, int keycode);
 extern int Android_OnJoy(int device_id, int axisnum, float value);
 extern int Android_OnHat(int device_id, int hat_id, int x, int y);
-extern int Android_AddJoystick(int device_id, const char *name, const char *desc, int vendor_id, int product_id, SDL_bool is_accelerometer, int button_mask, int naxes, int axis_mask, int nhats, int nballs);
+extern int Android_AddJoystick(int device_id, const char *name, const char *desc, int vendor_id, int product_id, SDL_bool is_accelerometer, int button_mask, int naxes, int axis_mask, int nhats, int nballs, SDL_bool can_rumble);
 extern int Android_RemoveJoystick(int device_id);
 
 /* A linked list of available joysticks */
@@ -46,6 +46,7 @@ typedef struct SDL_joylist_item
     SDL_Joystick *joystick;
     int nbuttons, naxes, nhats, nballs;
     int dpad_state;
+    SDL_bool can_rumble;
 
     struct SDL_joylist_item *next;
 } SDL_joylist_item;
diff --git a/src/main/android/SDL_android_main.c b/src/main/android/SDL_android_main.c
index 054738a..c4585af 100644
--- a/src/main/android/SDL_android_main.c
+++ b/src/main/android/SDL_android_main.c
@@ -5,3 +5,22 @@
 */
 
 /* vi: set ts=4 sw=4 expandtab: */
+
+
+#define SDL_MAIN_HANDLED
+
+#include "../../SDL_internal.h"
+
+
+
+typedef void (*Main)();
+Main CurrentMain;
+
+__attribute__ ((visibility("default"))) void SetMain(Main main) {
+    CurrentMain = main;
+}
+
+__attribute__ ((visibility("default"))) int SDL_main(int argc, char* argv[]) {
+    CurrentMain();
+    return 0;
+}
diff --git a/src/sensor/android/SDL_androidsensor.c b/src/sensor/android/SDL_androidsensor.c
index 3f57253..c06faf2 100644
--- a/src/sensor/android/SDL_androidsensor.c
+++ b/src/sensor/android/SDL_androidsensor.c
@@ -161,7 +161,7 @@ static void SDL_ANDROID_SensorUpdate(SDL_Sensor *sensor)
     ASensorEvent event;
     struct android_poll_source *source;
 
-    if (ALooper_pollAll(0, NULL, &events, (void **)&source) == LOOPER_ID_USER) {
+    if (ALooper_pollOnce(0, NULL, &events, (void **)&source) == LOOPER_ID_USER) {
         SDL_zero(event);
         while (ASensorEventQueue_getEvents(sensor->hwdata->eventqueue, &event, 1) > 0) {
             SDL_PrivateSensorUpdate(sensor, 0, event.data, SDL_arraysize(event.data));
diff --git a/src/thread/stdSDL_syscond.cpp b/src/thread/stdSDL_syscond.cpp
new file mode 100644
index 0000000..561d774
--- /dev/null
+++ b/src/thread/stdSDL_syscond.cpp
@@ -0,0 +1,151 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+extern "C" {
+#include "SDL_thread.h"
+}
+
+#include <chrono>
+#include <condition_variable>
+#include <ratio>
+#include <system_error>
+
+#include "SDL_sysmutex_c.h"
+
+struct SDL_cond
+{
+    std::condition_variable_any cpp_cond;
+};
+
+/* Create a condition variable */
+extern "C" SDL_cond *
+SDL_CreateCond(void)
+{
+    /* Allocate and initialize the condition variable */
+    try {
+        SDL_cond *cond = new SDL_cond;
+        return cond;
+    } catch (std::system_error &ex) {
+        SDL_SetError("unable to create a C++ condition variable: code=%d; %s", ex.code(), ex.what());
+        return NULL;
+    } catch (std::bad_alloc &) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+}
+
+/* Destroy a condition variable */
+extern "C" void
+SDL_DestroyCond(SDL_cond *cond)
+{
+    if (cond) {
+        delete cond;
+    }
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+extern "C" int
+SDL_CondSignal(SDL_cond *cond)
+{
+    if (!cond) {
+        return SDL_InvalidParamError("cond");
+    }
+
+    cond->cpp_cond.notify_one();
+    return 0;
+}
+
+/* Restart all threads that are waiting on the condition variable */
+extern "C" int
+SDL_CondBroadcast(SDL_cond *cond)
+{
+    if (!cond) {
+        return SDL_InvalidParamError("cond");
+    }
+
+    cond->cpp_cond.notify_all();
+    return 0;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+   The mutex must be locked before entering this function!
+   The mutex is unlocked during the wait, and locked again after the wait.
+
+Typical use:
+
+Thread A:
+    SDL_LockMutex(lock);
+    while ( ! condition ) {
+        SDL_CondWait(cond, lock);
+    }
+    SDL_UnlockMutex(lock);
+
+Thread B:
+    SDL_LockMutex(lock);
+    ...
+    condition = true;
+    ...
+    SDL_CondSignal(cond);
+    SDL_UnlockMutex(lock);
+ */
+extern "C" int
+SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
+{
+    if (cond == NULL) {
+        return SDL_InvalidParamError("cond");
+    }
+
+    if (mutex == NULL) {
+        return SDL_InvalidParamError("mutex");
+    }
+
+    try {
+        std::unique_lock<std::recursive_mutex> cpp_lock(mutex->cpp_mutex, std::adopt_lock_t());
+        if (ms == SDL_MUTEX_MAXWAIT) {
+            cond->cpp_cond.wait(
+                cpp_lock);
+            cpp_lock.release();
+            return 0;
+        } else {
+            auto wait_result = cond->cpp_cond.wait_for(
+                cpp_lock,
+                std::chrono::duration<Uint32, std::milli>(ms));
+            cpp_lock.release();
+            if (wait_result == std::cv_status::timeout) {
+                return SDL_MUTEX_TIMEDOUT;
+            } else {
+                return 0;
+            }
+        }
+    } catch (std::system_error &ex) {
+        return SDL_SetError("unable to wait on a C++ condition variable: code=%d; %s", ex.code(), ex.what());
+    }
+}
+
+/* Wait on the condition variable forever */
+extern "C" int
+SDL_CondWait(SDL_cond *cond, SDL_mutex *mutex)
+{
+    return SDL_CondWaitTimeout(cond, mutex, SDL_MUTEX_MAXWAIT);
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/stdSDL_sysmutex.cpp b/src/thread/stdSDL_sysmutex.cpp
new file mode 100644
index 0000000..bc04bed
--- /dev/null
+++ b/src/thread/stdSDL_sysmutex.cpp
@@ -0,0 +1,102 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+extern "C" {
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+}
+
+#include <system_error>
+
+#include "SDL_sysmutex_c.h"
+#include <Windows.h>
+
+/* Create a mutex */
+extern "C" SDL_mutex *
+SDL_CreateMutex(void)
+{
+    /* Allocate and initialize the mutex */
+    try {
+        SDL_mutex *mutex = new SDL_mutex;
+        return mutex;
+    } catch (std::system_error &ex) {
+        SDL_SetError("unable to create a C++ mutex: code=%d; %s", ex.code(), ex.what());
+        return NULL;
+    } catch (std::bad_alloc &) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+}
+
+/* Free the mutex */
+extern "C" void
+SDL_DestroyMutex(SDL_mutex *mutex)
+{
+    if (mutex) {
+        delete mutex;
+    }
+}
+
+/* Lock the mutex */
+extern "C" int
+SDL_LockMutex(SDL_mutex *mutex) SDL_NO_THREAD_SAFETY_ANALYSIS /* clang doesn't know about NULL mutexes */
+{
+    if (mutex == NULL) {
+        return 0;
+    }
+
+    try {
+        mutex->cpp_mutex.lock();
+        return 0;
+    } catch (std::system_error &ex) {
+        return SDL_SetError("unable to lock a C++ mutex: code=%d; %s", ex.code(), ex.what());
+    }
+}
+
+/* TryLock the mutex */
+int SDL_TryLockMutex(SDL_mutex *mutex)
+{
+    int retval = 0;
+
+    if (!mutex) {
+        return 0;
+    }
+
+    if (mutex->cpp_mutex.try_lock() == false) {
+        retval = SDL_MUTEX_TIMEDOUT;
+    }
+    return retval;
+}
+
+/* Unlock the mutex */
+extern "C" int
+SDL_UnlockMutex(SDL_mutex *mutex) SDL_NO_THREAD_SAFETY_ANALYSIS /* clang doesn't know about NULL mutexes */
+{
+    if (mutex == NULL) {
+        return 0;
+    }
+
+    mutex->cpp_mutex.unlock();
+    return 0;
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/stdSDL_sysmutex_c.h b/src/thread/stdSDL_sysmutex_c.h
new file mode 100644
index 0000000..dd53ee8
--- /dev/null
+++ b/src/thread/stdSDL_sysmutex_c.h
@@ -0,0 +1,30 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "SDL_config.h"
+
+#include <mutex>
+
+struct SDL_mutex
+{
+    std::recursive_mutex cpp_mutex;
+};
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/stdSDL_systhread.cpp b/src/thread/stdSDL_systhread.cpp
new file mode 100644
index 0000000..3d93a01
--- /dev/null
+++ b/src/thread/stdSDL_systhread.cpp
@@ -0,0 +1,164 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+/* Thread management routines for SDL */
+
+extern "C" {
+#include "SDL_thread.h"
+#include "../SDL_thread_c.h"
+#include "../SDL_systhread.h"
+}
+
+#include <mutex>
+#include <thread>
+#include <system_error>
+
+#ifdef __WINRT__
+#include <Windows.h>
+#endif
+
+static void RunThread(void *args)
+{
+    SDL_RunThread((SDL_Thread *)args);
+}
+
+extern "C" int
+SDL_SYS_CreateThread(SDL_Thread *thread)
+{
+    try {
+        // !!! FIXME: no way to set a thread stack size here.
+        std::thread cpp_thread(RunThread, thread);
+        thread->handle = (void *)new std::thread(std::move(cpp_thread));
+        return 0;
+    } catch (std::system_error &ex) {
+        return SDL_SetError("unable to start a C++ thread: code=%d; %s", ex.code(), ex.what());
+    } catch (std::bad_alloc &) {
+        return SDL_OutOfMemory();
+    }
+}
+
+extern "C" void
+SDL_SYS_SetupThread(const char *name)
+{
+    // Make sure a thread ID gets assigned ASAP, for debugging purposes:
+    SDL_ThreadID();
+    return;
+}
+
+extern "C" SDL_threadID
+SDL_ThreadID(void)
+{
+#ifdef __WINRT__
+    return GetCurrentThreadId();
+#else
+    // HACK: Mimick a thread ID, if one isn't otherwise available.
+    static thread_local SDL_threadID current_thread_id = 0;
+    static SDL_threadID next_thread_id = 1;
+    static std::mutex next_thread_id_mutex;
+
+    if (current_thread_id == 0) {
+        std::lock_guard<std::mutex> lock(next_thread_id_mutex);
+        current_thread_id = next_thread_id;
+        ++next_thread_id;
+    }
+
+    return current_thread_id;
+#endif
+}
+
+extern "C" int
+SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
+{
+#ifdef __WINRT__
+    int value;
+
+    if (priority == SDL_THREAD_PRIORITY_LOW) {
+        value = THREAD_PRIORITY_LOWEST;
+    } else if (priority == SDL_THREAD_PRIORITY_HIGH) {
+        value = THREAD_PRIORITY_HIGHEST;
+    } else if (priority == SDL_THREAD_PRIORITY_TIME_CRITICAL) {
+        // FIXME: WinRT does not support TIME_CRITICAL! -flibit
+        SDL_LogWarn(SDL_LOG_CATEGORY_SYSTEM, "TIME_CRITICAL unsupported, falling back to HIGHEST");
+        value = THREAD_PRIORITY_HIGHEST;
+    } else {
+        value = THREAD_PRIORITY_NORMAL;
+    }
+    if (!SetThreadPriority(GetCurrentThread(), value)) {
+        return WIN_SetError("SetThreadPriority()");
+    }
+    return 0;
+#else
+    return SDL_Unsupported();
+#endif
+}
+
+extern "C" void
+SDL_SYS_WaitThread(SDL_Thread *thread)
+{
+    if (!thread) {
+        return;
+    }
+
+    try {
+        std::thread *cpp_thread = (std::thread *)thread->handle;
+        if (cpp_thread->joinable()) {
+            cpp_thread->join();
+        }
+    } catch (std::system_error &) {
+        // An error occurred when joining the thread.  SDL_WaitThread does not,
+        // however, seem to provide a means to report errors to its callers
+        // though!
+    }
+}
+
+extern "C" void
+SDL_SYS_DetachThread(SDL_Thread *thread)
+{
+    if (!thread) {
+        return;
+    }
+
+    try {
+        std::thread *cpp_thread = (std::thread *)thread->handle;
+        if (cpp_thread->joinable()) {
+            cpp_thread->detach();
+        }
+    } catch (std::system_error &) {
+        // An error occurred when detaching the thread.  SDL_DetachThread does not,
+        // however, seem to provide a means to report errors to its callers
+        // though!
+    }
+}
+
+extern "C" SDL_TLSData *
+SDL_SYS_GetTLSData(void)
+{
+    return SDL_Generic_GetTLSData();
+}
+
+extern "C" int
+SDL_SYS_SetTLSData(SDL_TLSData *data)
+{
+    return SDL_Generic_SetTLSData(data);
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/stdSDL_systhread_c.h b/src/thread/stdSDL_systhread_c.h
new file mode 100644
index 0000000..5cf9d11
--- /dev/null
+++ b/src/thread/stdSDL_systhread_c.h
@@ -0,0 +1,26 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "SDL_config.h"
+
+/* For a thread handle, use a void pointer to a std::thread */
+typedef void *SYS_ThreadHandle;
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/stdcpp/SDL_syscond.cpp b/src/thread/stdcpp/SDL_syscond.cpp
deleted file mode 100644
index 561d774..0000000
--- a/src/thread/stdcpp/SDL_syscond.cpp
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
-  Simple DirectMedia Layer
-  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-*/
-#include "../../SDL_internal.h"
-
-extern "C" {
-#include "SDL_thread.h"
-}
-
-#include <chrono>
-#include <condition_variable>
-#include <ratio>
-#include <system_error>
-
-#include "SDL_sysmutex_c.h"
-
-struct SDL_cond
-{
-    std::condition_variable_any cpp_cond;
-};
-
-/* Create a condition variable */
-extern "C" SDL_cond *
-SDL_CreateCond(void)
-{
-    /* Allocate and initialize the condition variable */
-    try {
-        SDL_cond *cond = new SDL_cond;
-        return cond;
-    } catch (std::system_error &ex) {
-        SDL_SetError("unable to create a C++ condition variable: code=%d; %s", ex.code(), ex.what());
-        return NULL;
-    } catch (std::bad_alloc &) {
-        SDL_OutOfMemory();
-        return NULL;
-    }
-}
-
-/* Destroy a condition variable */
-extern "C" void
-SDL_DestroyCond(SDL_cond *cond)
-{
-    if (cond) {
-        delete cond;
-    }
-}
-
-/* Restart one of the threads that are waiting on the condition variable */
-extern "C" int
-SDL_CondSignal(SDL_cond *cond)
-{
-    if (!cond) {
-        return SDL_InvalidParamError("cond");
-    }
-
-    cond->cpp_cond.notify_one();
-    return 0;
-}
-
-/* Restart all threads that are waiting on the condition variable */
-extern "C" int
-SDL_CondBroadcast(SDL_cond *cond)
-{
-    if (!cond) {
-        return SDL_InvalidParamError("cond");
-    }
-
-    cond->cpp_cond.notify_all();
-    return 0;
-}
-
-/* Wait on the condition variable for at most 'ms' milliseconds.
-   The mutex must be locked before entering this function!
-   The mutex is unlocked during the wait, and locked again after the wait.
-
-Typical use:
-
-Thread A:
-    SDL_LockMutex(lock);
-    while ( ! condition ) {
-        SDL_CondWait(cond, lock);
-    }
-    SDL_UnlockMutex(lock);
-
-Thread B:
-    SDL_LockMutex(lock);
-    ...
-    condition = true;
-    ...
-    SDL_CondSignal(cond);
-    SDL_UnlockMutex(lock);
- */
-extern "C" int
-SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
-{
-    if (cond == NULL) {
-        return SDL_InvalidParamError("cond");
-    }
-
-    if (mutex == NULL) {
-        return SDL_InvalidParamError("mutex");
-    }
-
-    try {
-        std::unique_lock<std::recursive_mutex> cpp_lock(mutex->cpp_mutex, std::adopt_lock_t());
-        if (ms == SDL_MUTEX_MAXWAIT) {
-            cond->cpp_cond.wait(
-                cpp_lock);
-            cpp_lock.release();
-            return 0;
-        } else {
-            auto wait_result = cond->cpp_cond.wait_for(
-                cpp_lock,
-                std::chrono::duration<Uint32, std::milli>(ms));
-            cpp_lock.release();
-            if (wait_result == std::cv_status::timeout) {
-                return SDL_MUTEX_TIMEDOUT;
-            } else {
-                return 0;
-            }
-        }
-    } catch (std::system_error &ex) {
-        return SDL_SetError("unable to wait on a C++ condition variable: code=%d; %s", ex.code(), ex.what());
-    }
-}
-
-/* Wait on the condition variable forever */
-extern "C" int
-SDL_CondWait(SDL_cond *cond, SDL_mutex *mutex)
-{
-    return SDL_CondWaitTimeout(cond, mutex, SDL_MUTEX_MAXWAIT);
-}
-
-/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/stdcpp/SDL_sysmutex.cpp b/src/thread/stdcpp/SDL_sysmutex.cpp
deleted file mode 100644
index bc04bed..0000000
--- a/src/thread/stdcpp/SDL_sysmutex.cpp
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
-  Simple DirectMedia Layer
-  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-*/
-#include "../../SDL_internal.h"
-
-extern "C" {
-#include "SDL_thread.h"
-#include "SDL_systhread_c.h"
-}
-
-#include <system_error>
-
-#include "SDL_sysmutex_c.h"
-#include <Windows.h>
-
-/* Create a mutex */
-extern "C" SDL_mutex *
-SDL_CreateMutex(void)
-{
-    /* Allocate and initialize the mutex */
-    try {
-        SDL_mutex *mutex = new SDL_mutex;
-        return mutex;
-    } catch (std::system_error &ex) {
-        SDL_SetError("unable to create a C++ mutex: code=%d; %s", ex.code(), ex.what());
-        return NULL;
-    } catch (std::bad_alloc &) {
-        SDL_OutOfMemory();
-        return NULL;
-    }
-}
-
-/* Free the mutex */
-extern "C" void
-SDL_DestroyMutex(SDL_mutex *mutex)
-{
-    if (mutex) {
-        delete mutex;
-    }
-}
-
-/* Lock the mutex */
-extern "C" int
-SDL_LockMutex(SDL_mutex *mutex) SDL_NO_THREAD_SAFETY_ANALYSIS /* clang doesn't know about NULL mutexes */
-{
-    if (mutex == NULL) {
-        return 0;
-    }
-
-    try {
-        mutex->cpp_mutex.lock();
-        return 0;
-    } catch (std::system_error &ex) {
-        return SDL_SetError("unable to lock a C++ mutex: code=%d; %s", ex.code(), ex.what());
-    }
-}
-
-/* TryLock the mutex */
-int SDL_TryLockMutex(SDL_mutex *mutex)
-{
-    int retval = 0;
-
-    if (!mutex) {
-        return 0;
-    }
-
-    if (mutex->cpp_mutex.try_lock() == false) {
-        retval = SDL_MUTEX_TIMEDOUT;
-    }
-    return retval;
-}
-
-/* Unlock the mutex */
-extern "C" int
-SDL_UnlockMutex(SDL_mutex *mutex) SDL_NO_THREAD_SAFETY_ANALYSIS /* clang doesn't know about NULL mutexes */
-{
-    if (mutex == NULL) {
-        return 0;
-    }
-
-    mutex->cpp_mutex.unlock();
-    return 0;
-}
-
-/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/stdcpp/SDL_sysmutex_c.h b/src/thread/stdcpp/SDL_sysmutex_c.h
deleted file mode 100644
index dd53ee8..0000000
--- a/src/thread/stdcpp/SDL_sysmutex_c.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
-  Simple DirectMedia Layer
-  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-*/
-#include "SDL_config.h"
-
-#include <mutex>
-
-struct SDL_mutex
-{
-    std::recursive_mutex cpp_mutex;
-};
-
-/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/stdcpp/SDL_systhread.cpp b/src/thread/stdcpp/SDL_systhread.cpp
deleted file mode 100644
index 3d93a01..0000000
--- a/src/thread/stdcpp/SDL_systhread.cpp
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
-  Simple DirectMedia Layer
-  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-*/
-#include "../../SDL_internal.h"
-
-/* Thread management routines for SDL */
-
-extern "C" {
-#include "SDL_thread.h"
-#include "../SDL_thread_c.h"
-#include "../SDL_systhread.h"
-}
-
-#include <mutex>
-#include <thread>
-#include <system_error>
-
-#ifdef __WINRT__
-#include <Windows.h>
-#endif
-
-static void RunThread(void *args)
-{
-    SDL_RunThread((SDL_Thread *)args);
-}
-
-extern "C" int
-SDL_SYS_CreateThread(SDL_Thread *thread)
-{
-    try {
-        // !!! FIXME: no way to set a thread stack size here.
-        std::thread cpp_thread(RunThread, thread);
-        thread->handle = (void *)new std::thread(std::move(cpp_thread));
-        return 0;
-    } catch (std::system_error &ex) {
-        return SDL_SetError("unable to start a C++ thread: code=%d; %s", ex.code(), ex.what());
-    } catch (std::bad_alloc &) {
-        return SDL_OutOfMemory();
-    }
-}
-
-extern "C" void
-SDL_SYS_SetupThread(const char *name)
-{
-    // Make sure a thread ID gets assigned ASAP, for debugging purposes:
-    SDL_ThreadID();
-    return;
-}
-
-extern "C" SDL_threadID
-SDL_ThreadID(void)
-{
-#ifdef __WINRT__
-    return GetCurrentThreadId();
-#else
-    // HACK: Mimick a thread ID, if one isn't otherwise available.
-    static thread_local SDL_threadID current_thread_id = 0;
-    static SDL_threadID next_thread_id = 1;
-    static std::mutex next_thread_id_mutex;
-
-    if (current_thread_id == 0) {
-        std::lock_guard<std::mutex> lock(next_thread_id_mutex);
-        current_thread_id = next_thread_id;
-        ++next_thread_id;
-    }
-
-    return current_thread_id;
-#endif
-}
-
-extern "C" int
-SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
-{
-#ifdef __WINRT__
-    int value;
-
-    if (priority == SDL_THREAD_PRIORITY_LOW) {
-        value = THREAD_PRIORITY_LOWEST;
-    } else if (priority == SDL_THREAD_PRIORITY_HIGH) {
-        value = THREAD_PRIORITY_HIGHEST;
-    } else if (priority == SDL_THREAD_PRIORITY_TIME_CRITICAL) {
-        // FIXME: WinRT does not support TIME_CRITICAL! -flibit
-        SDL_LogWarn(SDL_LOG_CATEGORY_SYSTEM, "TIME_CRITICAL unsupported, falling back to HIGHEST");
-        value = THREAD_PRIORITY_HIGHEST;
-    } else {
-        value = THREAD_PRIORITY_NORMAL;
-    }
-    if (!SetThreadPriority(GetCurrentThread(), value)) {
-        return WIN_SetError("SetThreadPriority()");
-    }
-    return 0;
-#else
-    return SDL_Unsupported();
-#endif
-}
-
-extern "C" void
-SDL_SYS_WaitThread(SDL_Thread *thread)
-{
-    if (!thread) {
-        return;
-    }
-
-    try {
-        std::thread *cpp_thread = (std::thread *)thread->handle;
-        if (cpp_thread->joinable()) {
-            cpp_thread->join();
-        }
-    } catch (std::system_error &) {
-        // An error occurred when joining the thread.  SDL_WaitThread does not,
-        // however, seem to provide a means to report errors to its callers
-        // though!
-    }
-}
-
-extern "C" void
-SDL_SYS_DetachThread(SDL_Thread *thread)
-{
-    if (!thread) {
-        return;
-    }
-
-    try {
-        std::thread *cpp_thread = (std::thread *)thread->handle;
-        if (cpp_thread->joinable()) {
-            cpp_thread->detach();
-        }
-    } catch (std::system_error &) {
-        // An error occurred when detaching the thread.  SDL_DetachThread does not,
-        // however, seem to provide a means to report errors to its callers
-        // though!
-    }
-}
-
-extern "C" SDL_TLSData *
-SDL_SYS_GetTLSData(void)
-{
-    return SDL_Generic_GetTLSData();
-}
-
-extern "C" int
-SDL_SYS_SetTLSData(SDL_TLSData *data)
-{
-    return SDL_Generic_SetTLSData(data);
-}
-
-/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/stdcpp/SDL_systhread_c.h b/src/thread/stdcpp/SDL_systhread_c.h
deleted file mode 100644
index 5cf9d11..0000000
--- a/src/thread/stdcpp/SDL_systhread_c.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
-  Simple DirectMedia Layer
-  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-*/
-#include "SDL_config.h"
-
-/* For a thread handle, use a void pointer to a std::thread */
-typedef void *SYS_ThreadHandle;
-
-/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/SDL_egl.c b/src/video/SDL_egl.c
index a89c0e8..0483004 100644
--- a/src/video/SDL_egl.c
+++ b/src/video/SDL_egl.c
@@ -249,6 +249,36 @@ void *SDL_EGL_GetProcAddress(_THIS, const char *proc)
         const Uint32 eglver = (((Uint32)_this->egl_data->egl_version_major) << 16) | ((Uint32)_this->egl_data->egl_version_minor);
         const SDL_bool is_egl_15_or_later = eglver >= ((((Uint32)1) << 16) | 5);
 
+        /* For OSMesa, try OSMesaGetProcAddress first (if available and context is ready)
+         * This ensures we get zink's glGetString instead of system EGL's
+         * IMPORTANT: Only use OSMesaGetProcAddress after OSMesa context is created and made current
+         * Otherwise, the returned function pointers may not work correctly
+         */
+#ifdef __ANDROID__
+        const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+        SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+        if (is_osmesa && _this->egl_data->opengl_dll_handle) {
+            /* Check if OSMesa context is already initialized
+             * We can check this by trying to get OSMesaGetCurrentContext
+             * If it returns non-NULL, the context is ready
+             */
+            void* (*OSMesaGetCurrentContext)(void) = (void* (*)(void))
+                SDL_LoadFunction(_this->egl_data->opengl_dll_handle, "OSMesaGetCurrentContext");
+            if (OSMesaGetCurrentContext && OSMesaGetCurrentContext() != NULL) {
+                /* OSMesa context is ready, use OSMesaGetProcAddress */
+                void* (*OSMesaGetProcAddress)(const char*) = (void* (*)(const char*))
+                    SDL_LoadFunction(_this->egl_data->opengl_dll_handle, "OSMesaGetProcAddress");
+                if (OSMesaGetProcAddress) {
+                    retval = OSMesaGetProcAddress(proc);
+                    if (retval) {
+                        SDL_Log("SDL_EGL: Using OSMesaGetProcAddress for %s (context ready)", proc);
+                    }
+                }
+            }
+            /* If OSMesa context is not ready yet, fall through to EGL methods */
+        }
+#endif
+
         /* EGL 1.5 can use eglGetProcAddress() for any symbol. 1.4 and earlier can't use it for core entry points. */
         if (!retval && is_egl_15_or_later && _this->egl_data->eglGetProcAddress) {
             retval = _this->egl_data->eglGetProcAddress(proc);
@@ -776,29 +806,34 @@ static int SDL_EGL_PrivateChooseConfig(_THIS, SDL_bool set_config_caveat_none)
         attribs[i++] = EGL_PBUFFER_BIT;
     }
 
-    attribs[i++] = EGL_RENDERABLE_TYPE;
-    if (_this->gl_config.profile_mask == SDL_GL_CONTEXT_PROFILE_ES) {
-#ifdef EGL_KHR_create_context
-        if (_this->gl_config.major_version >= 3 &&
-            SDL_EGL_HasExtension(_this, SDL_EGL_DISPLAY_EXTENSION, "EGL_KHR_create_context")) {
-            attribs[i++] = EGL_OPENGL_ES3_BIT_KHR;
-        } else
-#endif
-            if (_this->gl_config.major_version >= 2) {
-            attribs[i++] = EGL_OPENGL_ES2_BIT;
-        } else {
-            attribs[i++] = EGL_OPENGL_ES_BIT;
-        }
-        _this->egl_data->eglBindAPI(EGL_OPENGL_ES_API);
-    } else {
-        attribs[i++] = EGL_OPENGL_BIT;
-        _this->egl_data->eglBindAPI(EGL_OPENGL_API);
-    }
-
-    if (_this->egl_data->egl_surfacetype) {
-        attribs[i++] = EGL_SURFACE_TYPE;
-        attribs[i++] = _this->egl_data->egl_surfacetype;
-    }
+//    /* Skip EGL_RENDERABLE_TYPE for OSMesa/Zink compatibility (similar to gl4es fix)
+//    * Set SDL_EGL_SKIP_RENDERABLE_TYPE=1 to skip this attribute */
+//    const char* skip_renderable_type = SDL_getenv("SDL_EGL_SKIP_RENDERABLE_TYPE");
+//    if (!skip_renderable_type || SDL_strcmp(skip_renderable_type, "1") != 0) {
+//        attribs[i++] = EGL_RENDERABLE_TYPE;
+//        if (_this->gl_config.profile_mask == SDL_GL_CONTEXT_PROFILE_ES) {
+//#ifdef EGL_KHR_create_context
+//            if (_this->gl_config.major_version >= 3 &&
+//                SDL_EGL_HasExtension(_this, SDL_EGL_DISPLAY_EXTENSION, "EGL_KHR_create_context")) {
+//                attribs[i++] = EGL_OPENGL_ES3_BIT_KHR;
+//            } else
+//#endif
+//            if (_this->gl_config.major_version >= 2) {
+//                attribs[i++] = EGL_OPENGL_ES2_BIT;
+//            } else {
+//                attribs[i++] = EGL_OPENGL_ES_BIT;
+//            }
+//            _this->egl_data->eglBindAPI(EGL_OPENGL_ES_API);
+//        } else {
+//            attribs[i++] = EGL_OPENGL_BIT;
+//            _this->egl_data->eglBindAPI(EGL_OPENGL_API);
+//        }
+//    }
+//
+//    if (_this->egl_data->egl_surfacetype) {
+//        attribs[i++] = EGL_SURFACE_TYPE;
+//        attribs[i++] = _this->egl_data->egl_surfacetype;
+//    }
 
     attribs[i++] = EGL_NONE;
 
@@ -973,6 +1008,63 @@ SDL_GLContext SDL_EGL_CreateContext(_THIS, EGLSurface egl_surface)
 #endif
 
     /* Set the context version and other attributes. */
+#ifdef __ANDROID__
+    /* Special handling for gl4es/zink on Android:
+     * - gl4es needs GLES context (translates desktop GL to ES)
+     * - Native zink needs GLES context (on Android without OSMesa)
+     * - OSMesa zink provides true desktop GL and needs desktop GL context
+     */
+    const char *fna3d_driver_attr = SDL_getenv("FNA3D_OPENGL_DRIVER");
+    const char *gl_driver = SDL_getenv("SDL_VIDEO_GL_DRIVER");
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+
+    /* Detect OSMesa (library path contains "OSMesa" or "osmesa") */
+    SDL_bool is_osmesa = (gl_driver && SDL_strcasestr(gl_driver, "osmesa")) ||
+                         (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    SDL_bool is_gl4es = (fna3d_driver_attr && SDL_strcasecmp(fna3d_driver_attr, "gl4es") == 0);
+    SDL_bool is_zink = (fna3d_driver_attr &&
+                        (SDL_strcasecmp(fna3d_driver_attr, "zink") == 0 ||
+                         SDL_strcasecmp(fna3d_driver_attr, "zink25") == 0));
+
+    /* Only gl4es and native zink (without OSMesa) need GLES context */
+    if (is_gl4es || (is_zink && !is_osmesa)) {
+        /* Use GLES context attributes */
+        int gles_version = 3;
+
+        /* Check LIBGL_ES env var to override gl4es backend version */
+        if (is_gl4es) {
+            const char *libgl_es = SDL_getenv("LIBGL_ES");
+            if (libgl_es && SDL_strcmp(libgl_es, "2") == 0) {
+                gles_version = 2;
+                SDL_Log("SDL_EGL: LIBGL_ES=2 detected, using GLES 2.0 backend for gl4es");
+            }
+        }
+
+        attribs[attr++] = EGL_CONTEXT_CLIENT_VERSION;
+        attribs[attr++] = gles_version;
+
+        SDL_Log("SDL_EGL: Creating GLES %d context for %s (using ES API)",
+                gles_version, fna3d_driver_attr);
+    } else if (is_osmesa && is_zink) {
+        /* OSMesa zink: On Android, we still need to use ES API for context creation
+         * OSMesa will handle desktop OpenGL calls internally, even with an ES context
+         * This is because Android EGL only supports EGL_OPENGL_ES_API */
+#ifdef __ANDROID__
+        /* On Android, use ES context (OSMesa handles desktop GL internally) */
+        int gles_version = 3;  /* Use GLES 3.0 for OSMesa zink on Android */
+        SDL_Log("SDL_EGL: OSMesa zink detected on Android, using ES context (OSMesa handles desktop GL internally)");
+        attribs[attr++] = EGL_CONTEXT_CLIENT_VERSION;
+        attribs[attr++] = gles_version;
+        SDL_Log("SDL_EGL: Creating GLES %d context for OSMesa zink (using ES API)", gles_version);
+        /* Continue with ES context creation */
+#else
+        /* On non-Android platforms, use desktop GL context */
+        SDL_Log("SDL_EGL: OSMesa zink detected, using desktop GL context (not forcing GLES)");
+        /* Fall through to normal desktop GL context creation below */
+#endif
+    } else
+#endif
     if ((major_version < 3 || (minor_version == 0 && profile_es)) &&
         _this->gl_config.flags == 0 &&
         (profile_mask == 0 || profile_es)) {
@@ -1028,12 +1120,71 @@ SDL_GLContext SDL_EGL_CreateContext(_THIS, EGLSurface egl_surface)
     attribs[attr++] = EGL_NONE;
 
     /* Bind the API */
+#ifdef __ANDROID__
+    /* API binding strategy on Android:
+     * - Android EGL only supports EGL_OPENGL_ES_API, not EGL_OPENGL_API
+     * - Even with OSMesa zink, we must use EGL_OPENGL_ES_API to create the context
+     * - OSMesa will handle desktop OpenGL calls internally, even with an ES context
+     * - gl4es: Use EGL_OPENGL_ES_API (translates desktop GL to ES)
+     * - zink (with or without OSMesa): Use EGL_OPENGL_ES_API (OSMesa handles desktop GL internally)
+     */
+    const char *fna3d_driver = SDL_getenv("FNA3D_OPENGL_DRIVER");
+    const char *gl_driver_bind = SDL_getenv("SDL_VIDEO_GL_DRIVER");
+    const char *fna3d_gl_lib_bind = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    int force_es_api = 0;
+
+    /* Detect OSMesa */
+    SDL_bool is_osmesa_bind = (gl_driver_bind && SDL_strcasestr(gl_driver_bind, "osmesa")) ||
+                              (fna3d_gl_lib_bind && SDL_strcasestr(fna3d_gl_lib_bind, "osmesa"));
+
+    /* On Android, always use EGL_OPENGL_ES_API (even for OSMesa zink) */
+    if (fna3d_driver) {
+        if (SDL_strcasecmp(fna3d_driver, "gl4es") == 0) {
+            force_es_api = 1;
+            SDL_Log("SDL_EGL: gl4es detected, using EGL_OPENGL_ES_API");
+        } else if ((SDL_strcasecmp(fna3d_driver, "zink") == 0 ||
+                    SDL_strcasecmp(fna3d_driver, "zink25") == 0)) {
+            /* On Android, always use ES API (OSMesa handles desktop GL internally) */
+            force_es_api = 1;
+            if (is_osmesa_bind) {
+                SDL_Log("SDL_EGL: OSMesa zink detected, using EGL_OPENGL_ES_API (OSMesa handles desktop GL internally)");
+            } else {
+                SDL_Log("SDL_EGL: Native zink detected, using EGL_OPENGL_ES_API");
+            }
+        }
+    }
+
+    if (profile_es || force_es_api) {
+        _this->egl_data->apitype = EGL_OPENGL_ES_API;
+    } else {
+        _this->egl_data->apitype = EGL_OPENGL_API;
+    }
+
+    SDL_Log("SDL_EGL: Attempting to bind API: %s (profile_mask=%d, major=%d, minor=%d, force_es_api=%d)",
+            _this->egl_data->apitype == EGL_OPENGL_ES_API ? "EGL_OPENGL_ES_API" : "EGL_OPENGL_API",
+            _this->gl_config.profile_mask,
+            _this->gl_config.major_version,
+            _this->gl_config.minor_version,
+            force_es_api);
+#else
     if (profile_es) {
         _this->egl_data->apitype = EGL_OPENGL_ES_API;
     } else {
         _this->egl_data->apitype = EGL_OPENGL_API;
     }
-    _this->egl_data->eglBindAPI(_this->egl_data->apitype);
+#endif
+
+    if (_this->egl_data->eglBindAPI(_this->egl_data->apitype) == EGL_FALSE) {
+        EGLint error = _this->egl_data->eglGetError();
+#ifdef __ANDROID__
+        SDL_Log("SDL_EGL: eglBindAPI failed with error 0x%x", error);
+        if (!profile_es && !force_es_api) {
+            SDL_Log("SDL_EGL: Desktop OpenGL API not supported on Android");
+        }
+#endif
+        SDL_EGL_SetError("Could not bind EGL API", "eglBindAPI");
+        return NULL;
+    }
 
     egl_context = _this->egl_data->eglCreateContext(_this->egl_data->egl_display,
                                                     _this->egl_data->egl_config,
diff --git a/src/video/android/SDL_androidgl.c b/src/video/android/SDL_androidgl.c
index 5e5ef60..8d881ca 100644
--- a/src/video/android/SDL_androidgl.c
+++ b/src/video/android/SDL_androidgl.c
@@ -22,6 +22,8 @@
 
 #if defined(SDL_VIDEO_DRIVER_ANDROID) && defined(SDL_VIDEO_OPENGL_EGL)
 
+#include <unistd.h> // for usleep
+
 /* Android SDL video driver implementation */
 
 #include "SDL_video.h"
@@ -33,12 +35,216 @@
 #include "../../core/android/SDL_android.h"
 
 #include <android/log.h>
+#include <android/native_window.h>
 
 #include <dlfcn.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <time.h>
+#include "../../SDL_internal.h"  // SDL_bool is defined here
+#include "SDL_androidwindow.h"  // For SDL_WindowData
+
+/* FPS 计算相关 - 使用滑动窗口平均实现精准稳定的检测 */
+#define FPS_SAMPLE_COUNT 30  /* 滑动窗口大小（帧数）- 减小以提高响应速度 */
+#define FPS_UPDATE_INTERVAL_NS 100000000LL  /* 更新间隔 100ms（纳秒）- 更频繁更新 */
+
+static Uint64 g_frame_times[FPS_SAMPLE_COUNT] = {0};  /* 帧时间戳环形缓冲 */
+static int g_frame_index = 0;                          /* 当前帧索引 */
+static int g_frame_count = 0;                          /* 有效帧计数 */
+static Uint64 g_last_update_ns = 0;                    /* 上次更新时间 */
+static float g_fps_current = 0.0f;                     /* 当前 FPS */
+static float g_fps_smoothed = 0.0f;                    /* 平滑后的 FPS */
+static float g_frame_time_ms = 0.0f;                   /* 平均帧时间 */
+static char g_fps_env_buffer[64] = {0};
+static SDL_bool g_fps_initialized = SDL_FALSE;
+
+/* 获取当前时间（纳秒级精度） */
+static Uint64 GetTimeNS(void)
+{
+    struct timespec ts;
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    return (Uint64)ts.tv_sec * 1000000000ULL + (Uint64)ts.tv_nsec;
+}
+
+/* 初始化 FPS 追踪 */
+static void InitFPSTracking(void)
+{
+    if (g_fps_initialized) return;
+    g_fps_initialized = SDL_TRUE;
+    
+    SDL_memset(g_frame_times, 0, sizeof(g_frame_times));
+    g_frame_index = 0;
+    g_frame_count = 0;
+    g_last_update_ns = GetTimeNS();
+    g_fps_current = 0.0f;
+    g_fps_smoothed = 0.0f;
+    
+    setenv("RAL_FPS", "0", 1);
+    setenv("RAL_FRAME_TIME", "0", 1);
+    
+    __android_log_print(ANDROID_LOG_INFO, "SDL_FPS", 
+        "FPS tracking initialized (sample window: %d frames)", FPS_SAMPLE_COUNT);
+}
+
+/* 更新 FPS - 使用滑动窗口平均 */
+static void UpdateFPS(void)
+{
+    Uint64 current_ns = GetTimeNS();
+    
+    /* 记录帧时间到环形缓冲 */
+    g_frame_times[g_frame_index] = current_ns;
+    g_frame_index = (g_frame_index + 1) % FPS_SAMPLE_COUNT;
+    if (g_frame_count < FPS_SAMPLE_COUNT) {
+        g_frame_count++;
+    }
+    
+    /* 检查是否需要更新 FPS 显示 */
+    Uint64 elapsed_ns = current_ns - g_last_update_ns;
+    if (elapsed_ns < FPS_UPDATE_INTERVAL_NS) {
+        return;
+    }
+    g_last_update_ns = current_ns;
+    
+    /* 计算滑动窗口内的平均 FPS */
+    if (g_frame_count >= 2) {
+        /* 找到窗口内最老的帧 */
+        int oldest_index = (g_frame_index - g_frame_count + FPS_SAMPLE_COUNT) % FPS_SAMPLE_COUNT;
+        int newest_index = (g_frame_index - 1 + FPS_SAMPLE_COUNT) % FPS_SAMPLE_COUNT;
+        
+        Uint64 oldest_time = g_frame_times[oldest_index];
+        Uint64 newest_time = g_frame_times[newest_index];
+        
+        if (newest_time > oldest_time) {
+            Uint64 window_duration_ns = newest_time - oldest_time;
+            int frame_intervals = g_frame_count - 1;
+            
+            /* 计算 FPS: (帧数-1) / 时间窗口 */
+            g_fps_current = (float)frame_intervals * 1000000000.0f / (float)window_duration_ns;
+            
+            /* 计算平均帧时间 (ms) */
+            g_frame_time_ms = (float)window_duration_ns / (float)frame_intervals / 1000000.0f;
+            
+            /* 指数移动平均平滑 (EMA)，alpha = 0.5 - 更快响应 */
+            if (g_fps_smoothed <= 0.0f) {
+                g_fps_smoothed = g_fps_current;
+            } else {
+                g_fps_smoothed = g_fps_smoothed * 0.5f + g_fps_current * 0.5f;
+            }
+        }
+    }
+    
+    /* 通过环境变量传递给 Java */
+    SDL_snprintf(g_fps_env_buffer, sizeof(g_fps_env_buffer), "%.1f", g_fps_smoothed);
+    setenv("RAL_FPS", g_fps_env_buffer, 1);
+    
+    SDL_snprintf(g_fps_env_buffer, sizeof(g_fps_env_buffer), "%.2f", g_frame_time_ms);
+    setenv("RAL_FRAME_TIME", g_fps_env_buffer, 1);
+}
 
 int Android_GLES_MakeCurrent(_THIS, SDL_Window *window, SDL_GLContext context)
 {
     if (window && context) {
+        /* For OSMesa zink, create OSMesa context when SDL context is made current
+         * This ensures OSMesa context is ready before FNA3D calls glGetString()
+         */
+#ifdef __ANDROID__
+        const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+        SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+            "MakeCurrent: FNA3D_OPENGL_LIBRARY=%s, is_osmesa=%d",
+            fna3d_gl_lib ? fna3d_gl_lib : "(null)", is_osmesa);
+
+        if (is_osmesa) {
+            /* Try to load osm_renderer_init from the main library using dlopen/dlsym
+             * Try multiple possible library names
+             */
+            static bool osm_initialized = false;
+            if (!osm_initialized) {
+                const char* lib_names[] = {"libralaunch.so", "libmain.so", NULL};
+                void *main_lib = NULL;
+                int i = 0;
+
+                while (lib_names[i] != NULL && main_lib == NULL) {
+                    main_lib = dlopen(lib_names[i], RTLD_LAZY | RTLD_LOCAL);
+                    if (main_lib) {
+                        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                            "✓ Loaded library: %s", lib_names[i]);
+                    } else {
+                        __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                            "⚠ Failed to load %s: %s", lib_names[i], dlerror());
+                    }
+                    i++;
+                }
+
+                if (main_lib) {
+                    typedef bool (*osm_renderer_init_func)(ANativeWindow*);
+                    typedef bool (*osm_renderer_is_available_func)(void);
+                    typedef bool (*osm_renderer_is_initialized_func)(void);
+
+                    osm_renderer_is_available_func osm_is_available = (osm_renderer_is_available_func)
+                        dlsym(main_lib, "osm_renderer_is_available");
+                    osm_renderer_is_initialized_func osm_is_initialized = (osm_renderer_is_initialized_func)
+                        dlsym(main_lib, "osm_renderer_is_initialized");
+                    osm_renderer_init_func osm_init = (osm_renderer_init_func)
+                        dlsym(main_lib, "osm_renderer_init");
+
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "OSMesa function pointers: is_available=%p, is_initialized=%p, init=%p",
+                        osm_is_available, osm_is_initialized, osm_init);
+
+                    if (osm_is_available && osm_is_initialized && osm_init) {
+                        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                            "All OSMesa functions loaded successfully");
+
+                        if (osm_is_available() && !osm_is_initialized()) {
+                            SDL_WindowData *data = (SDL_WindowData *)window->driverdata;
+                            ANativeWindow *native_window = data->native_window;
+
+                            if (native_window != NULL) {
+                                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                                    "Creating OSMesa context when SDL context is made current...");
+                                if (osm_init(native_window)) {
+                                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                                        "✓ OSMesa context created and made current");
+
+                                    // CRITICAL: Wait a bit for OSMesa context to be fully ready
+                                    // This ensures glGetString() will work when FNA3D initializes
+                                    // zink needs time to initialize the Vulkan device and OpenGL context
+                                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                                        "Waiting for OSMesa context to be fully ready...");
+                                    usleep(150000); // 150ms delay for zink initialization
+
+                                    osm_initialized = true;
+                                } else {
+                                    __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                                        "⚠ Failed to create OSMesa context, will use EGL fallback");
+                                }
+                            } else {
+                                __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                                    "⚠ Native window is NULL, cannot create OSMesa context");
+                            }
+                        } else if (osm_is_initialized()) {
+                            osm_initialized = true;
+                        }
+                    } else {
+                        __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                            "⚠ Failed to load OSMesa functions from library");
+                    }
+                    // Don't close main_lib, we need the symbols to remain available
+                } else {
+                    __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                        "⚠ Failed to load any OSMesa-compatible library");
+                }
+            }
+
+            /* For OSMesa, don't call SDL_EGL_MakeCurrent - OSMesa manages its own context */
+            __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                "OSMesa mode: returning success without EGL MakeCurrent");
+            return 0;
+        }
+#endif
         return SDL_EGL_MakeCurrent(_this, ((SDL_WindowData *)window->driverdata)->egl_surface, context);
     } else {
         return SDL_EGL_MakeCurrent(_this, NULL, NULL);
@@ -51,6 +257,23 @@ SDL_GLContext Android_GLES_CreateContext(_THIS, SDL_Window *window)
 
     Android_ActivityMutex_Lock_Running();
 
+#ifdef __ANDROID__
+    /* For OSMesa, return a dummy context since OSMesa manages its own OpenGL context */
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    if (is_osmesa) {
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+            "OSMesa detected, returning dummy GL context (OSMesa manages its own context)");
+        /* Return a non-NULL dummy pointer to indicate success
+         * OSMesa context is managed separately via osm_init_context()
+         * We use (void*)1 as a sentinel value to indicate "OSMesa mode"
+         */
+        SDL_UnlockMutex(Android_ActivityMutex);
+        return (SDL_GLContext)(void*)1;
+    }
+#endif
+
     ret = SDL_EGL_CreateContext(_this, ((SDL_WindowData *)window->driverdata)->egl_surface);
 
     SDL_UnlockMutex(Android_ActivityMutex);
@@ -62,8 +285,47 @@ int Android_GLES_SwapWindow(_THIS, SDL_Window *window)
 {
     int retval;
 
+    /* 初始化并更新 FPS（滑动窗口平均算法） */
+    InitFPSTracking();
+    UpdateFPS();
+
     SDL_LockMutex(Android_ActivityMutex);
 
+#ifdef __ANDROID__
+    /* For OSMesa/zink rendering, use OSMesa swap buffers instead of EGL
+     * OSMesa renders to a software buffer that needs to be copied to the native window
+     */
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    if (is_osmesa) {
+        /* Try to call osm_swap_buffers from the main library */
+        static void (*osm_swap_buffers_fn)(void) = NULL;
+        static SDL_bool osm_swap_init_attempted = SDL_FALSE;
+
+        if (!osm_swap_init_attempted) {
+            osm_swap_init_attempted = SDL_TRUE;
+            void* main_lib = dlopen("libmain.so", RTLD_LAZY | RTLD_LOCAL);
+            if (main_lib) {
+                osm_swap_buffers_fn = (void (*)(void)) dlsym(main_lib, "osm_swap_buffers");
+                if (osm_swap_buffers_fn) {
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "✓ Found osm_swap_buffers function for OSMesa rendering");
+                }
+            }
+        }
+
+        if (osm_swap_buffers_fn) {
+            osm_swap_buffers_fn();
+            SDL_UnlockMutex(Android_ActivityMutex);
+            return 0;
+        } else {
+            __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                "⚠ osm_swap_buffers not found, falling back to EGL swap");
+        }
+    }
+#endif
+
     /* The following two calls existed in the original Java code
      * If you happen to have a device that's affected by their removal,
      * please report to our bug tracker. -- Gabriel
@@ -77,12 +339,257 @@ int Android_GLES_SwapWindow(_THIS, SDL_Window *window)
 
     return retval;
 }
-
 int Android_GLES_LoadLibrary(_THIS, const char *path)
 {
+    const char* custom_egl_path = NULL;
+    const char* current_renderer = NULL;
+    const char* egl_lib_path = NULL;
+
+    __android_log_print(ANDROID_LOG_INFO, "Android_GLES", "Android_GLES_LoadLibrary called, path=%s", path ? path : "(null)");
+
+    /* 检查是否已经通过 Android_LoadRenderer() 预加载了渲染器
+     * 如果已预加载，需要传递库路径让 SDL_EGL_LoadLibrary 使用该库
+     */
+    #ifdef SDL_VIDEO_DRIVER_ANDROID
+    extern const char* Android_GetCurrentRenderer(void);
+    extern const char* Android_GetCurrentRendererLibPath(void);
+
+    current_renderer = Android_GetCurrentRenderer();
+    egl_lib_path = Android_GetCurrentRendererLibPath();
+
+    __android_log_print(ANDROID_LOG_INFO, "Android_GLES", "current_renderer = %s, egl_lib_path = %s",
+                        current_renderer ? current_renderer : "(null)",
+                        egl_lib_path ? egl_lib_path : "(null)");
+
+    if (current_renderer && SDL_strcmp(current_renderer, "native") != 0 && SDL_strcmp(current_renderer, "none") != 0) {
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "Renderer '%s' already preloaded", current_renderer);
+
+        /* 检查是否是 OSMesa 渲染器（zink/virgl 等）
+         * OSMesa 渲染器需要使用 OSMesa 库路径
+         * 其他渲染器（gl4es 等）使用系统 EGL + 自定义 GL 库
+         */
+        const char* fna3d_ogl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+        SDL_bool is_osmesa = (fna3d_ogl_lib && SDL_strcasestr(fna3d_ogl_lib, "osmesa"));
+
+        // 检查是否是 zink 渲染器
+        const char *fna3d_driver = SDL_getenv("FNA3D_OPENGL_DRIVER");
+        SDL_bool is_zink = (current_renderer && (SDL_strcmp(current_renderer, "zink") == 0 ||
+                                                 SDL_strstr(current_renderer, "vulkan_zink") != NULL)) ||
+                           (fna3d_driver && SDL_strcasecmp(fna3d_driver, "zink") == 0);
+
+        if (is_zink) {
+            __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "Zink renderer detected, checking Vulkan availability...");
+
+            /* 检查 VULKAN_PTR 环境变量（由 Java 层设置） */
+            const char* vulkan_ptr = SDL_getenv("VULKAN_PTR");
+            if (vulkan_ptr != NULL && vulkan_ptr[0] != '\0') {
+                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                            "✓ Vulkan library already loaded (VULKAN_PTR=%s)", vulkan_ptr);
+            } else {
+                /* 如果 Java 层没有加载，尝试在这里加载 */
+                __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                            "⚠ VULKAN_PTR not set, attempting to load Vulkan...");
+                void* vulkan_handle = dlopen("libvulkan.so", RTLD_LAZY | RTLD_LOCAL);
+                if (vulkan_handle != NULL) {
+                    char envval[64];
+                    SDL_snprintf(envval, sizeof(envval), "%p", vulkan_handle);
+                    SDL_setenv("VULKAN_PTR", envval, 1);
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                                "✓ Vulkan library loaded: %s", envval);
+                } else {
+                    __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                                "⚠ Failed to load Vulkan library: %s", dlerror());
+                }
+            }
+        }
+
+        /* 对于 OSMesa 渲染器，传递 OSMesa 库路径给 SDL_EGL_LoadLibrary
+         * OSMesa 不使用真正的 EGL，但需要加载库以获取 GL 函数
+         */
+        if (is_osmesa && fna3d_ogl_lib) {
+            __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "OSMesa renderer: Using OSMesa library: %s", fna3d_ogl_lib);
+            return SDL_EGL_LoadLibrary(_this, fna3d_ogl_lib, (NativeDisplayType)0, 0);
+        }
+
+        /* 对于非 OSMesa 渲染器（gl4es 等），使用系统 EGL
+         * GL 函数将通过 eglGetProcAddress 或 dlsym 从预加载的 GL 库获取
+         */
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "Non-OSMesa renderer '%s': Using system EGL with preloaded GL library",
+                    current_renderer);
+        return SDL_EGL_LoadLibrary(_this, egl_lib_path, (NativeDisplayType)0, 0);
+    }
+    #endif
+
+    /* 检查是否通过 FNA3D_OPENGL_LIBRARY 环境变量指定了自定义 EGL 库
+     * 使用环境变量指定库路径绕过 Android 链接器命名空间限制
+     */
+    custom_egl_path = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+
+    if (custom_egl_path != NULL && custom_egl_path[0] != '\0') {
+        SDL_LogInfo(SDL_LOG_CATEGORY_VIDEO,
+                    "Android_GLES_LoadLibrary: Using custom EGL from FNA3D_OPENGL_LIBRARY: %s",
+                    custom_egl_path);
+        return SDL_EGL_LoadLibrary(_this, custom_egl_path, (NativeDisplayType)0, 0);
+    }
+
+    /* 回退到默认行为(使用系统 libEGL.so) */
     return SDL_EGL_LoadLibrary(_this, path, (NativeDisplayType)0, 0);
 }
 
+void *Android_GLES_GetProcAddress(_THIS, const char *proc)
+{
+#ifdef __ANDROID__
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    /* For OSMesa, use OSMesaGetProcAddress */
+    if (is_osmesa) {
+        static void* (*OSMesaGetProcAddress_fn)(const char*) = NULL;
+        static SDL_bool osmesa_proc_init_attempted = SDL_FALSE;
+        static int log_count = 0;
+
+        if (!osmesa_proc_init_attempted) {
+            osmesa_proc_init_attempted = SDL_TRUE;
+            void* osmesa_lib = dlopen(fna3d_gl_lib, RTLD_LAZY | RTLD_LOCAL);
+            if (osmesa_lib) {
+                OSMesaGetProcAddress_fn = (void* (*)(const char*)) dlsym(osmesa_lib, "OSMesaGetProcAddress");
+                if (OSMesaGetProcAddress_fn) {
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "✓ OSMesaGetProcAddress loaded for GL function lookup from %s", fna3d_gl_lib);
+                } else {
+                    __android_log_print(ANDROID_LOG_ERROR, "Android_GLES",
+                        "✗ OSMesaGetProcAddress NOT found in %s", fna3d_gl_lib);
+                }
+            } else {
+                __android_log_print(ANDROID_LOG_ERROR, "Android_GLES",
+                    "✗ Failed to dlopen OSMesa library: %s - %s", fna3d_gl_lib, dlerror());
+            }
+        }
+
+        if (OSMesaGetProcAddress_fn) {
+            void* result = OSMesaGetProcAddress_fn(proc);
+            if (log_count < 20) {
+                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "GetProcAddress(%s) -> OSMesa: %p", proc, result);
+                log_count++;
+            }
+            if (result) {
+                return result;
+            }
+            __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                "OSMesaGetProcAddress returned NULL for %s, falling back to EGL", proc);
+        }
+    }
+
+    /* For custom GL libraries (gl4es, etc.), try dlsym first
+     * These libraries provide their own GL implementations
+     */
+    if (fna3d_gl_lib && !is_osmesa) {
+        static void* custom_gl_lib = NULL;
+        static SDL_bool custom_gl_init_attempted = SDL_FALSE;
+        static int custom_log_count = 0;
+
+        if (!custom_gl_init_attempted) {
+            custom_gl_init_attempted = SDL_TRUE;
+            /* Open with RTLD_NOLOAD to get the already-loaded library handle */
+            custom_gl_lib = dlopen(fna3d_gl_lib, RTLD_LAZY | RTLD_NOLOAD);
+            if (!custom_gl_lib) {
+                /* Try opening it normally */
+                custom_gl_lib = dlopen(fna3d_gl_lib, RTLD_LAZY | RTLD_LOCAL);
+            }
+            if (custom_gl_lib) {
+                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "✓ Custom GL library loaded for function lookup: %s", fna3d_gl_lib);
+            } else {
+                __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                    "⚠ Failed to load custom GL library: %s - %s", fna3d_gl_lib, dlerror());
+            }
+        }
+
+        if (custom_gl_lib) {
+            void* result = dlsym(custom_gl_lib, proc);
+            if (result) {
+                if (custom_log_count < 20) {
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "GetProcAddress(%s) -> Custom GL: %p", proc, result);
+                    custom_log_count++;
+                }
+                return result;
+            }
+            /* Fall through to EGL if custom library doesn't have the function */
+        }
+    }
+#endif
+    return SDL_EGL_GetProcAddress(_this, proc);
+}
+
+void Android_GLES_UnloadLibrary(_THIS)
+{
+    SDL_EGL_UnloadLibrary(_this);
+}
+
+int Android_GLES_SetSwapInterval(_THIS, int interval)
+{
+    return SDL_EGL_SetSwapInterval(_this, interval);
+}
+
+int Android_GLES_GetSwapInterval(_THIS)
+{
+    return SDL_EGL_GetSwapInterval(_this);
+}
+
+void Android_GLES_DeleteContext(_THIS, SDL_GLContext context)
+{
+#ifdef __ANDROID__
+    /* For OSMesa, the context is a dummy pointer - don't call EGL delete */
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    if (is_osmesa) {
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+            "OSMesa mode: skipping EGL DeleteContext (OSMesa manages its own context)");
+        return;
+    }
+#endif
+    SDL_EGL_DeleteContext(_this, context);
+}
+
+void Android_GLES_GetDrawableSize(_THIS, SDL_Window *window, int *w, int *h)
+{
+#ifdef __ANDROID__
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    if (is_osmesa) {
+        /* For OSMesa, get the drawable size from the native window */
+        SDL_WindowData *data = (SDL_WindowData *)window->driverdata;
+        if (data && data->native_window) {
+            int native_w = ANativeWindow_getWidth(data->native_window);
+            int native_h = ANativeWindow_getHeight(data->native_window);
+            if (native_w > 0 && native_h > 0) {
+                if (w) *w = native_w;
+                if (h) *h = native_h;
+                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "OSMesa GetDrawableSize: %dx%d (from ANativeWindow)", native_w, native_h);
+                return;
+            }
+        }
+        /* Fall back to window size */
+        if (w) *w = window->w;
+        if (h) *h = window->h;
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+            "OSMesa GetDrawableSize: %dx%d (fallback to window size)", window->w, window->h);
+        return;
+    }
+#endif
+    /* Default: use window size in pixels */
+    SDL_GetWindowSizeInPixels(window, w, h);
+}
+
 #endif /* SDL_VIDEO_DRIVER_ANDROID */
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/android/SDL_androidgl.h b/src/video/android/SDL_androidgl.h
index 4fb505c..e0fbf35 100644
--- a/src/video/android/SDL_androidgl.h
+++ b/src/video/android/SDL_androidgl.h
@@ -23,10 +23,16 @@
 #ifndef SDL_androidgl_h_
 #define SDL_androidgl_h_
 
+int Android_GLES_LoadLibrary(_THIS, const char *path);
+void *Android_GLES_GetProcAddress(_THIS, const char *proc);
+void Android_GLES_UnloadLibrary(_THIS);
 SDL_GLContext Android_GLES_CreateContext(_THIS, SDL_Window *window);
 int Android_GLES_MakeCurrent(_THIS, SDL_Window *window, SDL_GLContext context);
+int Android_GLES_SetSwapInterval(_THIS, int interval);
+int Android_GLES_GetSwapInterval(_THIS);
 int Android_GLES_SwapWindow(_THIS, SDL_Window *window);
-int Android_GLES_LoadLibrary(_THIS, const char *path);
+void Android_GLES_DeleteContext(_THIS, SDL_GLContext context);
+void Android_GLES_GetDrawableSize(_THIS, SDL_Window *window, int *w, int *h);
 
 #endif /* SDL_androidgl_h_ */
 
diff --git a/src/video/android/SDL_androidmouse.c b/src/video/android/SDL_androidmouse.c
index 29ee05e..82bf251 100644
--- a/src/video/android/SDL_androidmouse.c
+++ b/src/video/android/SDL_androidmouse.c
@@ -251,6 +251,67 @@ void Android_OnMouse(SDL_Window *window, int state, int action, float x, float y
     }
 }
 
+/* Mouse events without state tracking - for direct control */
+void Android_OnMouseDirect(SDL_Window *window, int state, int action, float x, float y, SDL_bool relative)
+{
+    Uint8 button;
+
+    if (!window) {
+        return;
+    }
+
+    switch (action) {
+    case ACTION_DOWN:
+        button = TranslateButton(state);
+        SDL_SendMouseMotion(window, 0, relative, (int)x, (int)y);
+        SDL_SendMouseButton(window, 0, SDL_PRESSED, button);
+        break;
+
+    case ACTION_UP:
+        button = TranslateButton(state);
+        SDL_SendMouseMotion(window, 0, relative, (int)x, (int)y);
+        SDL_SendMouseButton(window, 0, SDL_RELEASED, button);
+        break;
+
+    case ACTION_MOVE:
+    case ACTION_HOVER_MOVE:
+        SDL_SendMouseMotion(window, 0, relative, (int)x, (int)y);
+        break;
+
+    case ACTION_SCROLL:
+        SDL_SendMouseWheel(window, 0, x, y, SDL_MOUSEWHEEL_NORMAL);
+        break;
+
+    default:
+        break;
+    }
+}
+
+/* Direct mouse button send - bypasses last_state tracking for virtual controls */
+void Android_OnMouseButtonDirect(SDL_Window *window, int sdlButton, int pressed, float x, float y)
+{
+    if (!window) {
+        return;
+    }
+
+    /* First move to position */
+    SDL_SendMouseMotion(window, 0, SDL_FALSE, (int)x, (int)y);
+
+    /* Then send button event directly */
+    SDL_SendMouseButton(window, 0, pressed ? SDL_PRESSED : SDL_RELEASED, (Uint8)sdlButton);
+}
+
+/* Send mouse button without moving cursor - for virtual button controls */
+void Android_OnMouseButtonOnly(SDL_Window *window, int sdlButton, int pressed)
+{
+    if (!window) {
+        return;
+    }
+
+    /* Send button event only, don't move mouse cursor */
+    SDL_SendMouseButton(window, 0, pressed ? SDL_PRESSED : SDL_RELEASED, (Uint8)sdlButton);
+}
+
 #endif /* SDL_VIDEO_DRIVER_ANDROID */
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/android/SDL_androidmouse.h b/src/video/android/SDL_androidmouse.h
index 6ff7249..636441b 100644
--- a/src/video/android/SDL_androidmouse.h
+++ b/src/video/android/SDL_androidmouse.h
@@ -26,6 +26,9 @@
 
 extern void Android_InitMouse(void);
 extern void Android_OnMouse(SDL_Window *window, int button, int action, float x, float y, SDL_bool relative);
+extern void Android_OnMouseDirect(SDL_Window *window, int button, int action, float x, float y, SDL_bool relative);
+extern void Android_OnMouseButtonDirect(SDL_Window *window, int sdlButton, int pressed, float x, float y);
+extern void Android_OnMouseButtonOnly(SDL_Window *window, int sdlButton, int pressed);
 extern void Android_QuitMouse(void);
 
 #endif /* SDL_androidmouse_h_ */
diff --git a/src/video/android/SDL_androidrenderer.c b/src/video/android/SDL_androidrenderer.c
new file mode 100644
index 0000000..5c18a94
--- /dev/null
+++ b/src/video/android/SDL_androidrenderer.c
@@ -0,0 +1,400 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+*/
+
+/**
+ * SDL Android Dynamic Renderer Loader
+ *
+ * 基于环境变量的渲染器选择机制：
+ * 1. 读取 RALCORE_RENDERER 环境变量确定渲染器类型
+ * 2. 读取 RALCORE_EGL 环境变量（用于 ANGLE 等特殊渲染器）
+ * 3. 使用 dlopen(RTLD_GLOBAL) 加载对应的渲染器库
+ * 4. 通过 LD_PRELOAD 让系统自动使用加载的渲染器
+ */
+
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_ANDROID
+
+#include "SDL_androidrenderer.h"
+#include "SDL_androidgl.h"
+#include "SDL_hints.h"
+
+#include "../SDL_egl_c.h"
+
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <android/log.h>
+
+#define LOG_TAG "SDL_Renderer"
+#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
+#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
+
+/* 渲染器后端配置表 */
+static const SDL_RendererBackend RENDERER_BACKENDS[] = {
+    /* 系统原生 EGL/GLES (默认) */
+    {
+        .name = "native",
+        .egl_library = NULL,
+        .gles_library = NULL,
+        .need_preload = SDL_FALSE
+    },
+
+    /* gl4es (OpenGL 2.1 翻译到 GLES 2.0) */
+    {
+        .name = "gl4es",
+        .egl_library = "libEGL_gl4es.so",
+        .gles_library = "libGL_gl4es.so",
+        .need_preload = SDL_TRUE
+    },
+
+    /* ANGLE (OpenGL ES over Vulkan) */
+    {
+        .name = "angle",
+        .egl_library = "libEGL_angle.so",
+        .gles_library = "libGLESv2_angle.so",
+        .need_preload = SDL_TRUE
+    },
+
+    /* MobileGlues */
+    {
+        .name = "mobileglues",
+        .egl_library = "libmobileglues.so",
+        .gles_library = "libmobileglues.so",
+        .need_preload = SDL_TRUE
+    },
+
+    /* Zink (OpenGL over Vulkan via OSMesa) */
+    {
+        .name = "zink",
+        .egl_library = "libOSMesa.so",
+        .gles_library = "libOSMesa.so",
+        .need_preload = SDL_TRUE
+    },
+
+    /* DXVK (D3D11 over Vulkan) - FNA3D 使用 D3D11 驱动 + DXVK */
+    {
+        .name = "dxvk",
+        .egl_library = NULL,  /* DXVK 不需要 EGL，但需要设置 SDL hint */
+        .gles_library = NULL, /* DXVK 不需要 GLES */
+        .need_preload = SDL_TRUE  /* 需要设置 SDL hint */
+    },
+
+    /* 结束标记 */
+    {NULL, NULL, NULL, SDL_FALSE}
+};
+
+/* 当前加载的渲染器 */
+static const SDL_RendererBackend *current_renderer = NULL;
+static void *renderer_handle = NULL;  /* dlopen 返回的句柄 */
+
+/**
+ * 查找渲染器配置
+ */
+static const SDL_RendererBackend* FindRendererBackend(const char *name)
+{
+    if (!name || name[0] == '\0') {
+        return &RENDERER_BACKENDS[0];  /* 默认 native */
+    }
+
+    for (int i = 0; RENDERER_BACKENDS[i].name != NULL; i++) {
+        if (SDL_strcasecmp(RENDERER_BACKENDS[i].name, name) == 0) {
+            return &RENDERER_BACKENDS[i];
+        }
+    }
+
+    LOGE("Unknown renderer '%s', falling back to native", name);
+    return &RENDERER_BACKENDS[0];
+}
+
+/**
+ * 从环境变量获取渲染器名称
+ */
+static const char* GetRendererFromEnv(void)
+{
+    const char *ralcore_renderer = SDL_getenv("RALCORE_RENDERER");
+    const char *ralcore_egl = SDL_getenv("RALCORE_EGL");
+
+    if (ralcore_renderer != NULL) {
+        /* 映射 RALCORE_RENDERER 值到渲染器名称 */
+        if (SDL_strcmp(ralcore_renderer, "gl4es") == 0) {
+            return "gl4es";
+        } else if (SDL_strcmp(ralcore_renderer, "vulkan_zink") == 0) {
+            return "zink";
+        } else if (SDL_strcmp(ralcore_renderer, "gallium_virgl") == 0) {
+            return "virgl";
+        } else if (SDL_strcmp(ralcore_renderer, "gallium_freedreno") == 0) {
+            return "freedreno";
+        } else if (SDL_strcmp(ralcore_renderer, "dxvk") == 0) {
+            return "dxvk";
+        }
+    }
+
+    if (ralcore_egl != NULL && SDL_strstr(ralcore_egl, "angle") != NULL) {
+        return "angle";
+    }
+
+    return NULL; /* 使用默认 native 渲染器 */
+}
+
+/**
+ * 加载渲染器库
+ */
+SDL_bool Android_LoadRenderer(const char *renderer_name)
+{
+    const SDL_RendererBackend *backend;
+    const char *env_renderer;
+
+    LOGI("================================================================");
+    LOGI("  SDL Dynamic Renderer Loading");
+    LOGI("  Requested: %s", renderer_name ? renderer_name : "(null)");
+
+    /* 优先使用环境变量 */
+    env_renderer = GetRendererFromEnv();
+    if (env_renderer != NULL) {
+        LOGI("  Environment: RALCORE_RENDERER/RALCORE_EGL -> %s", env_renderer);
+        renderer_name = env_renderer;
+    }
+
+    LOGI("================================================================");
+
+    /* 查找渲染器配置 */
+    backend = FindRendererBackend(renderer_name);
+    if (!backend) {
+        LOGE("Failed to find renderer backend");
+        return SDL_FALSE;
+    }
+
+    LOGI("  Selected: %s", backend->name);
+
+    /* 如果是系统原生渲染器，无需加载 */
+    if (!backend->need_preload) {
+        LOGI("  Using system libEGL.so and libGLESv2.so");
+        current_renderer = backend;
+        return SDL_TRUE;
+    }
+
+    /* DXVK 渲染器特殊处理：设置 SDL hint 让 FNA3D 使用 D3D11 驱动 */
+    if (SDL_strcasecmp(backend->name, "dxvk") == 0) {
+        LOGI("  DXVK renderer: Setting FNA3D_FORCE_DRIVER=D3D11");
+        SDL_SetHint("FNA3D_FORCE_DRIVER", "D3D11");
+        /* DXVK WSI 使用 SDL2 */
+        setenv("DXVK_WSI_DRIVER", "SDL2", 1);
+        LOGI("  ✓ DXVK_WSI_DRIVER = SDL2");
+        /* 使用系统原生 EGL/GLES 因为 DXVK 不通过 OpenGL 工作 */
+        LOGI("  Using system libEGL.so (DXVK uses Vulkan directly via FNA3D D3D11 driver)");
+        current_renderer = backend;
+        return SDL_TRUE;
+    }
+
+    /* 检查库文件是否存在 */
+    if (!backend->egl_library) {
+        LOGE("  Renderer %s has no EGL library specified", backend->name);
+        return SDL_FALSE;
+    }
+
+    LOGI("  EGL Library: %s", backend->egl_library);
+    if (backend->gles_library && SDL_strcmp(backend->egl_library, backend->gles_library) != 0) {
+        LOGI("  GLES Library: %s", backend->gles_library);
+    }
+
+    /* 使用 dlopen 加载渲染器库 (RTLD_GLOBAL 很关键!) */
+    LOGI("  Loading with dlopen(RTLD_NOW | RTLD_GLOBAL)...");
+
+    const char *runtime_dir = getenv("RALCORE_RUNTIMEDIR");
+    const char *native_dir = getenv("RALCORE_NATIVEDIR");
+    
+    /* 
+     * 重要：先加载 GLES 库（如 libGL_gl4es.so），再加载 EGL 库
+     * 因为 EGL 库通常依赖 GLES 库
+     */
+    if (backend->gles_library && backend->gles_library != backend->egl_library) {
+        void *gles_handle = NULL;
+        char gles_path[512];
+        
+        LOGI("  Loading GLES library first: %s", backend->gles_library);
+        
+        /* 尝试从 runtime_libs 目录加载 GLES 库 */
+        if (!gles_handle && runtime_dir) {
+            SDL_snprintf(gles_path, sizeof(gles_path), "%s/%s", runtime_dir, backend->gles_library);
+            if (access(gles_path, F_OK) == 0) {
+                LOGI("  Trying runtime_libs path: %s", gles_path);
+                gles_handle = dlopen(gles_path, RTLD_NOW | RTLD_GLOBAL);
+                if (!gles_handle) {
+                    LOGE("  ✗ GLES dlopen failed: %s", dlerror());
+                } else {
+                    LOGI("  ✓ GLES library loaded from runtime_libs");
+                }
+            }
+        }
+        
+        /* 尝试从 native lib 目录加载 GLES 库 */
+        if (!gles_handle && native_dir) {
+            SDL_snprintf(gles_path, sizeof(gles_path), "%s/%s", native_dir, backend->gles_library);
+            if (access(gles_path, F_OK) == 0) {
+                LOGI("  Trying native lib path: %s", gles_path);
+                gles_handle = dlopen(gles_path, RTLD_NOW | RTLD_GLOBAL);
+                if (!gles_handle) {
+                    LOGE("  ✗ GLES dlopen failed: %s", dlerror());
+                } else {
+                    LOGI("  ✓ GLES library loaded from native lib");
+                }
+            }
+        }
+        
+        if (!gles_handle) {
+            LOGE("  ✗ Failed to load GLES library: %s", backend->gles_library);
+            LOGE("  Falling back to native renderer");
+            current_renderer = &RENDERER_BACKENDS[0];
+            return SDL_FALSE;
+        }
+    }
+
+    /* 现在加载 EGL 库 */
+    LOGI("  Loading EGL library: %s", backend->egl_library);
+    
+    /* 尝试从 runtime_libs 目录加载 EGL 库 */
+    if (!renderer_handle && runtime_dir) {
+        char full_path[512];
+        SDL_snprintf(full_path, sizeof(full_path), "%s/%s", runtime_dir, backend->egl_library);
+        if (access(full_path, F_OK) == 0) {
+            LOGI("  Trying runtime_libs path: %s", full_path);
+            renderer_handle = dlopen(full_path, RTLD_NOW | RTLD_GLOBAL);
+            if (!renderer_handle) {
+                LOGE("  ✗ EGL dlopen failed: %s", dlerror());
+            } else {
+                LOGI("  ✓ EGL library loaded from runtime_libs");
+            }
+        } else {
+            LOGE("  ✗ File does not exist: %s", full_path);
+        }
+    }
+    
+    /* 尝试从 native lib 目录加载 EGL 库 */
+    if (!renderer_handle && native_dir) {
+        char full_path[512];
+        SDL_snprintf(full_path, sizeof(full_path), "%s/%s", native_dir, backend->egl_library);
+        if (access(full_path, F_OK) == 0) {
+            LOGI("  Trying native lib path: %s", full_path);
+            renderer_handle = dlopen(full_path, RTLD_NOW | RTLD_GLOBAL);
+            if (!renderer_handle) {
+                LOGE("  ✗ EGL dlopen failed: %s", dlerror());
+            } else {
+                LOGI("  ✓ EGL library loaded from native lib");
+            }
+        }
+    }
+    
+    if (!renderer_handle) {
+        LOGE("  ✗ dlopen failed: %s", dlerror());
+        LOGE("  Falling back to native renderer");
+        current_renderer = &RENDERER_BACKENDS[0];
+        return SDL_FALSE;
+    }
+
+    LOGI("  ✓ dlopen success, handle = %p", renderer_handle);
+
+    /* 设置 LD_PRELOAD 环境变量 */
+    /* 注意：setenv 必须在 SDL 初始化之前调用才有效 */
+    /* 如果 SDL 已经初始化，需要在 Java 层设置 */
+    if (setenv("LD_PRELOAD", backend->egl_library, 1) == 0) {
+        LOGI("  ✓ LD_PRELOAD = %s", backend->egl_library);
+    } else {
+        LOGI("  ⚠ LD_PRELOAD already set or cannot be set");
+    }
+
+    /* 设置 FNA3D_OPENGL_DRIVER 让 FNA3D 知道使用哪个渲染器 */
+    if (backend->name && SDL_strcmp(backend->name, "native") != 0) {
+
+        /* 设置 SDL_VIDEO_GL_DRIVER 指向已加载的库
+    * 这样 SDL 就会使用这个库而不是再次 dlopen 系统库 */
+        setenv("SDL_VIDEO_GL_DRIVER", backend->egl_library, 1);
+        LOGI("  ✓ SDL_VIDEO_GL_DRIVER = %s", backend->egl_library);
+
+        setenv("FNA3D_OPENGL_DRIVER", backend->name, 1);
+        LOGI("  ✓ FNA3D_OPENGL_DRIVER = %s", backend->name);
+
+
+    }
+
+    /* 对于 gl4es，设置额外的环境变量 */
+    /* 注意：使用 setenv(..., 0) 表示不覆盖已有的环境变量 */
+    /* 这样 Box64Launcher 或 RendererConfig 设置的值优先 */
+    if (SDL_strcasecmp(backend->name, "gl4es") == 0) {
+        const char *existing_libgl_es = SDL_getenv("LIBGL_ES");
+        if (existing_libgl_es) {
+            LOGI("  LIBGL_ES already set to '%s', not overriding", existing_libgl_es);
+        } else {
+            setenv("LIBGL_ES", "3", 1);         /* 默认使用 GLES 3.0 (和 dotnet 一致) */
+        }
+        setenv("LIBGL_MIPMAP", "3", 0);     /* 启用 mipmap (不覆盖) */
+        setenv("LIBGL_NPOT", "1", 0);       /* 支持非 2 的幂次纹理 (不覆盖) */
+        setenv("LIBGL_SHRINKPOP", "0", 0);  /* 禁用纹理缩小 (不覆盖) */
+        LOGI("  ✓ gl4es environment configured (LIBGL_ES=%s)",
+             SDL_getenv("LIBGL_ES") ? SDL_getenv("LIBGL_ES") : "not set");
+    }
+
+    current_renderer = backend;
+    LOGI(" Renderer '%s' loaded successfully", backend->name);
+    LOGI("================================================================");
+
+    return SDL_TRUE;
+}
+
+/**
+ * 设置 GL 函数指针
+ *
+ * gl4es: 使用专用的 Android_GL4ES_* 函数（通过 AGL 接口）
+ * 其他渲染器: 使用标准 EGL 接口
+ */
+/* Forward declaration for OSMesa drawable size */
+extern void Android_GLES_GetDrawableSize(SDL_VideoDevice *_this, SDL_Window *window, int *w, int *h);
+
+SDL_bool Android_SetupGLFunctions(SDL_VideoDevice *device)
+{
+    const char *renderer_name;
+
+    if (!device) {
+        return SDL_FALSE;
+    }
+
+    renderer_name = current_renderer ? current_renderer->name : "native";
+    LOGI("Setting up GL functions for renderer: %s", renderer_name);
+
+
+
+    device->GL_LoadLibrary = Android_GLES_LoadLibrary;
+    device->GL_GetProcAddress = Android_GLES_GetProcAddress;
+    device->GL_UnloadLibrary = Android_GLES_UnloadLibrary;
+    device->GL_CreateContext = Android_GLES_CreateContext;
+    device->GL_MakeCurrent = Android_GLES_MakeCurrent;
+    device->GL_SetSwapInterval = Android_GLES_SetSwapInterval;
+    device->GL_GetSwapInterval = Android_GLES_GetSwapInterval;
+    device->GL_SwapWindow = Android_GLES_SwapWindow;
+    device->GL_DeleteContext = Android_GLES_DeleteContext;
+    device->GL_GetDrawableSize = Android_GLES_GetDrawableSize; /* CRITICAL for OSMesa */
+
+    LOGI("✓ GL functions configured");
+
+    return SDL_TRUE;
+}
+
+/**
+ * 获取当前渲染器名称
+ */
+const char* Android_GetCurrentRenderer(void)
+{
+    return current_renderer ? current_renderer->name : "none";
+}
+
+/**
+ * 获取当前渲染器的EGL库路径
+ */
+const char* Android_GetCurrentRendererLibPath(void)
+{
+    return current_renderer ? current_renderer->egl_library : NULL;
+}
+
+#endif /* SDL_VIDEO_DRIVER_ANDROID */
diff --git a/src/video/android/SDL_androidrenderer.h b/src/video/android/SDL_androidrenderer.h
new file mode 100644
index 0000000..2f4ec39
--- /dev/null
+++ b/src/video/android/SDL_androidrenderer.h
@@ -0,0 +1,77 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+/**
+ * @file SDL_androidrenderer.h
+ *
+ * Android Dynamic Renderer Loading
+
+ * 实现运行时动态切换渲染器，无需重新编译
+ */
+
+#ifndef SDL_androidrenderer_h_
+#define SDL_androidrenderer_h_
+
+#include "../../SDL_internal.h"
+#include "../SDL_sysvideo.h"
+
+/**
+ * 渲染器后端信息
+ */
+typedef struct {
+    const char *name;           /* 渲染器名称 (native, gl4es, angle, etc.) */
+    const char *egl_library;    /* EGL 库路径 (NULL = 系统默认) */
+    const char *gles_library;   /* GLES 库路径 (NULL = 系统默认) */
+    SDL_bool need_preload;      /* 是否需要通过 LD_PRELOAD 加载 */
+} SDL_RendererBackend;
+
+/**
+ * 动态加载渲染器
+ *
+ * 通过 dlopen + LD_PRELOAD 机制加载指定的渲染器库
+ *
+ * @param renderer_name 渲染器名称 (从环境变量 SDL_RENDERER 或 FNA3D_OPENGL_DRIVER 读取)
+ * @return SDL_TRUE 成功, SDL_FALSE 失败
+ */
+extern SDL_bool Android_LoadRenderer(const char *renderer_name);
+
+/**
+ * 设置 OpenGL 函数指针到 video device
+ *
+ * 根据加载的渲染器设置对应的 GL 函数指针
+ * 如果使用 LD_PRELOAD，所有渲染器都提供标准 EGL 接口，直接使用 SDL_EGL 函数
+ *
+ * @param device SDL video device
+ * @return SDL_TRUE 成功, SDL_FALSE 失败
+ */
+extern SDL_bool Android_SetupGLFunctions(SDL_VideoDevice *device);
+
+/**
+ * 获取当前加载的渲染器名称
+ */
+extern const char* Android_GetCurrentRenderer(void);
+
+/**
+ * 获取当前渲染器的EGL库路径
+ */
+extern const char* Android_GetCurrentRendererLibPath(void);
+
+#endif /* SDL_androidrenderer_h_ */
diff --git a/src/video/android/SDL_androidtouch.c b/src/video/android/SDL_androidtouch.c
index c44f2b0..af99e10 100644
--- a/src/video/android/SDL_androidtouch.c
+++ b/src/video/android/SDL_androidtouch.c
@@ -64,9 +64,21 @@ void Android_OnTouch(SDL_Window *window, int touch_device_id_in, int pointer_fin
     }
 
     fingerId = (SDL_FingerID)pointer_finger_id_in;
+    
+    /* Reduced logging - only log touch down/up, not every move event */
+    #if 0
+    __android_log_print(ANDROID_LOG_VERBOSE, "SDLTouch", 
+        "Android_OnTouch: action=%d finger=%d pos=(%.2f,%.2f)",
+        action, pointer_finger_id_in, x, y);
+    #endif
+    
     switch (action) {
     case ACTION_DOWN:
     case ACTION_POINTER_DOWN:
+        #if 0
+        __android_log_print(ANDROID_LOG_VERBOSE, "SDLTouch", 
+            "  -> SendTouch DOWN finger=%d", pointer_finger_id_in);
+        #endif
         SDL_SendTouch(touchDeviceId, fingerId, window, SDL_TRUE, x, y, p);
         break;
 
@@ -76,6 +88,10 @@ void Android_OnTouch(SDL_Window *window, int touch_device_id_in, int pointer_fin
 
     case ACTION_UP:
     case ACTION_POINTER_UP:
+        #if 0
+        __android_log_print(ANDROID_LOG_VERBOSE, "SDLTouch", 
+            "  -> SendTouch UP finger=%d", pointer_finger_id_in);
+        #endif
         SDL_SendTouch(touchDeviceId, fingerId, window, SDL_FALSE, x, y, p);
         break;
 
diff --git a/src/video/android/SDL_androidvideo.c b/src/video/android/SDL_androidvideo.c
index f54b4c3..b8fa8cd 100644
--- a/src/video/android/SDL_androidvideo.c
+++ b/src/video/android/SDL_androidvideo.c
@@ -34,6 +34,7 @@
 
 #include "SDL_androidvideo.h"
 #include "SDL_androidgl.h"
+
 #include "SDL_androidclipboard.h"
 #include "SDL_androidevents.h"
 #include "SDL_androidkeyboard.h"
@@ -42,6 +43,8 @@
 #include "SDL_androidwindow.h"
 #include "SDL_androidvulkan.h"
 #include "SDL_androidmessagebox.h"
+#include "SDL_androidrenderer.h"  /* Dynamic renderer loading */
+
 
 #define ANDROID_VID_DRIVER_NAME "Android"
 
@@ -120,23 +123,64 @@ static SDL_VideoDevice *Android_CreateDevice(void)
     device->SetWindowFullscreen = Android_SetWindowFullscreen;
     device->MinimizeWindow = Android_MinimizeWindow;
     device->SetWindowResizable = Android_SetWindowResizable;
+    device->SetWindowSize = Android_SetWindowSize;
+    device->SetWindowPosition = Android_SetWindowPosition;
     device->DestroyWindow = Android_DestroyWindow;
     device->GetWindowWMInfo = Android_GetWindowWMInfo;
 
     device->free = Android_DeleteDevice;
 
-    /* GL pointers */
-#ifdef SDL_VIDEO_OPENGL_EGL
-    device->GL_LoadLibrary = Android_GLES_LoadLibrary;
-    device->GL_GetProcAddress = Android_GLES_GetProcAddress;
-    device->GL_UnloadLibrary = Android_GLES_UnloadLibrary;
-    device->GL_CreateContext = Android_GLES_CreateContext;
-    device->GL_MakeCurrent = Android_GLES_MakeCurrent;
-    device->GL_SetSwapInterval = Android_GLES_SetSwapInterval;
-    device->GL_GetSwapInterval = Android_GLES_GetSwapInterval;
-    device->GL_SwapWindow = Android_GLES_SwapWindow;
-    device->GL_DeleteContext = Android_GLES_DeleteContext;
-#endif
+    /* ================================================================
+     * 🔥 Dynamic Renderer Loading
+     * ================================================================
+     *
+     * 支持运行时动态切换渲染器，无需重新编译
+     *
+     * 环境变量：
+     *   SDL_RENDERER 或 FNA3D_OPENGL_DRIVER
+     *     - native: 系统默认 (libEGL.so + libGLESv2.so)
+     *     - gl4es: OpenGL 2.1 翻译层
+     *     - angle: OpenGL ES over Vulkan
+     *     - zink: OpenGL over Vulkan
+     *
+     * 实现原理：
+     *   1. 通过 dlopen(RTLD_GLOBAL) 预加载渲染器库
+     *   2. 通过 LD_PRELOAD 劫持 SDL 的 dlopen("libEGL.so")
+     *   3. 所有渲染器都提供标准 EGL 接口
+     *   4. SDL 无感知，直接使用 Android_GLES_* 函数
+     */
+
+    /* 从环境变量读取渲染器配置 */
+    {
+        const char* renderer_name = SDL_getenv("SDL_RENDERER");
+    if (!renderer_name || renderer_name[0] == '\0') {
+        renderer_name = SDL_getenv("FNA3D_OPENGL_DRIVER");
+    }
+    if (!renderer_name || renderer_name[0] == '\0') {
+        renderer_name = "native";  /* 默认使用系统渲染器 */
+    }
+
+    /* 动态加载渲染器 */
+    if (!Android_LoadRenderer(renderer_name)) {
+        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO,
+                    "Failed to load renderer '%s', falling back to native",
+                    renderer_name);
+        Android_LoadRenderer("native");
+    }
+
+    /* 设置 GL 函数指针 */
+    /* 由于使用 LD_PRELOAD，所有渲染器都提供标准 EGL 接口 */
+    if (!Android_SetupGLFunctions(device)) {
+        SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Failed to setup GL functions");
+        SDL_free(data);
+        SDL_free(device);
+        return NULL;
+    }
+
+    SDL_LogInfo(SDL_LOG_CATEGORY_VIDEO,
+                "✅ Renderer initialized: %s",
+                Android_GetCurrentRenderer());
+    }
 
 #ifdef SDL_VIDEO_VULKAN
     device->Vulkan_LoadLibrary = Android_Vulkan_LoadLibrary;
@@ -197,6 +241,54 @@ int Android_VideoInit(_THIS)
 
     SDL_AddDisplayMode(&_this->displays[0], &mode);
 
+    // Lets add more display modes!
+    int alt_heights[] = {480, 600, 720, 768, 800, 960, 1024, 1080, 1152, 1280, 1440, 1536, 1600,
+                         1792, 1920};
+    int num_of_alts = sizeof(alt_heights) / sizeof(alt_heights[0]);
+    // Well we don't care about the order as SDL automatically sort them
+    for (int i = 0; i < num_of_alts; i++) {
+        if (alt_heights[i] < Android_DeviceHeight) {
+            int alt_width = (alt_heights[i] * Android_DeviceWidth) / Android_DeviceHeight;
+
+            SDL_DisplayMode alt_mode;
+            alt_mode.format = Android_ScreenFormat;
+            alt_mode.w = alt_width;
+            alt_mode.h = alt_heights[i];
+            alt_mode.refresh_rate = Android_ScreenRate;
+            alt_mode.driverdata = NULL;
+            SDL_AddDisplayMode(&_this->displays[0], &alt_mode);
+        }
+    }
+    // not yet implemented, because need to implement black borders on two sides, and fix touching
+//    // 4:3 aspect ratios
+//    for (int i = 0; i < num_of_alts; i++) {
+//        if (alt_heights[i] <= Android_DeviceHeight) {
+//            int alt_width = (alt_heights[i] * 4) / 3;
+//
+//            SDL_DisplayMode alt_mode;
+//            alt_mode.format = Android_ScreenFormat;
+//            alt_mode.w = alt_width;
+//            alt_mode.h = alt_heights[i];
+//            alt_mode.refresh_rate = Android_ScreenRate;
+//            alt_mode.driverdata = NULL;
+//            SDL_AddDisplayMode(&_this->displays[0], &alt_mode);
+//        }
+//    }
+//    // 16:9 aspect ratios
+//    for (int i = 0; i < num_of_alts; i++) {
+//        if (alt_heights[i] <= Android_DeviceHeight) {
+//            int alt_width = (alt_heights[i] * 16) / 9;
+//
+//            SDL_DisplayMode alt_mode;
+//            alt_mode.format = Android_ScreenFormat;
+//            alt_mode.w = alt_width;
+//            alt_mode.h = alt_heights[i];
+//            alt_mode.refresh_rate = Android_ScreenRate;
+//            alt_mode.driverdata = NULL;
+//            SDL_AddDisplayMode(&_this->displays[0], &alt_mode);
+//        }
+//    }
+
     Android_InitTouch();
 
     Android_InitMouse();
diff --git a/src/video/android/SDL_androidwindow.c b/src/video/android/SDL_androidwindow.c
index 2624331..4f43eac 100644
--- a/src/video/android/SDL_androidwindow.c
+++ b/src/video/android/SDL_androidwindow.c
@@ -33,6 +33,8 @@
 #include "SDL_androidwindow.h"
 #include "SDL_hints.h"
 
+#include <android/log.h>
+
 /* Currently only one window */
 SDL_Window *Android_Window = NULL;
 
@@ -41,17 +43,23 @@ int Android_CreateWindow(_THIS, SDL_Window *window)
     SDL_WindowData *data;
     int retval = 0;
 
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "🪟 Android_CreateWindow called, window=%p", window);
+
     Android_ActivityMutex_Lock_Running();
 
     if (Android_Window) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_Window", "❌ Already have a window!");
         retval = SDL_SetError("Android only supports one window");
         goto endfunction;
     }
 
     /* Set orientation */
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "Setting orientation...");
     Android_JNI_SetOrientation(window->w, window->h, window->flags & SDL_WINDOW_RESIZABLE, SDL_GetHint(SDL_HINT_ORIENTATIONS));
 
     /* Adjust the window data to match the screen */
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "Adjusting window size from %dx%d to %dx%d",
+        window->w, window->h, Android_SurfaceWidth, Android_SurfaceHeight);
     window->x = 0;
     window->y = 0;
     window->w = Android_SurfaceWidth;
@@ -64,42 +72,65 @@ int Android_CreateWindow(_THIS, SDL_Window *window)
     SDL_SetMouseFocus(window);
     SDL_SetKeyboardFocus(window);
 
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "Allocating window data...");
     data = (SDL_WindowData *)SDL_calloc(1, sizeof(*data));
     if (!data) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_Window", "❌ Out of memory!");
         retval = SDL_OutOfMemory();
         goto endfunction;
     }
 
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "Getting native window...");
     data->native_window = Android_JNI_GetNativeWindow();
 
     if (!data->native_window) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_Window", "❌ Could not fetch native window!");
         SDL_free(data);
         retval = SDL_SetError("Could not fetch native window");
         goto endfunction;
     }
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "✅ Native window obtained: %p", data->native_window);
 
     /* Do not create EGLSurface for Vulkan window since it will then make the window
        incompatible with vkCreateAndroidSurfaceKHR */
+    /* Also skip EGLSurface for OSMesa since OSMesa uses ANativeWindow_lock directly */
 #ifdef SDL_VIDEO_OPENGL_EGL
-    if (window->flags & SDL_WINDOW_OPENGL) {
-        data->egl_surface = SDL_EGL_CreateSurface(_this, (NativeWindowType)data->native_window);
-
-        if (data->egl_surface == EGL_NO_SURFACE) {
-            ANativeWindow_release(data->native_window);
-            SDL_free(data);
-            retval = -1;
-            goto endfunction;
+    {
+        const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+        SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+        if (is_osmesa) {
+            __android_log_print(ANDROID_LOG_INFO, "SDL_Window",
+                "OSMesa detected, skipping EGL surface creation (OSMesa uses ANativeWindow_lock)");
+            data->egl_surface = EGL_NO_SURFACE;
+        } else {
+            __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "SDL_VIDEO_OPENGL_EGL is defined, creating EGL surface...");
+            if (window->flags & SDL_WINDOW_OPENGL) {
+                data->egl_surface = SDL_EGL_CreateSurface(_this, (NativeWindowType)data->native_window);
+
+                if (data->egl_surface == EGL_NO_SURFACE) {
+                    __android_log_print(ANDROID_LOG_ERROR, "SDL_Window", "❌ Failed to create EGL surface!");
+                    ANativeWindow_release(data->native_window);
+                    SDL_free(data);
+                    retval = -1;
+                    goto endfunction;
+                }
+            }
         }
     }
+#else
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "SDL_VIDEO_OPENGL_EGL is NOT defined, skipping EGL surface creation");
 #endif
 
     window->driverdata = data;
     Android_Window = window;
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "✅ Android_CreateWindow succeeded!");
 
 endfunction:
 
     SDL_UnlockMutex(Android_ActivityMutex);
 
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "Android_CreateWindow returning %d", retval);
     return retval;
 }
 
@@ -170,6 +201,46 @@ void Android_SetWindowResizable(_THIS, SDL_Window *window, SDL_bool resizable)
     Android_JNI_SetOrientation(window->w, window->h, window->flags & SDL_WINDOW_RESIZABLE, SDL_GetHint(SDL_HINT_ORIENTATIONS));
 }
 
+void Android_SetWindowSize(_THIS, SDL_Window *window)
+{
+    /* Force window to always be fullscreen size - ignore any resize attempts */
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "🔒 Android_SetWindowSize called - forcing fullscreen size");
+
+    SDL_LockMutex(Android_ActivityMutex);
+
+    if (window == Android_Window) {
+        /* Always reset to fullscreen dimensions */
+        window->x = 0;
+        window->y = 0;
+        window->w = Android_SurfaceWidth;
+        window->h = Android_SurfaceHeight;
+
+        __android_log_print(ANDROID_LOG_INFO, "SDL_Window",
+            "✅ Window forced to fullscreen: %dx%d at (0,0)",
+            Android_SurfaceWidth, Android_SurfaceHeight);
+    }
+
+    SDL_UnlockMutex(Android_ActivityMutex);
+}
+
+void Android_SetWindowPosition(_THIS, SDL_Window *window)
+{
+    /* Force window to always be at (0,0) - ignore any position change attempts */
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "🔒 Android_SetWindowPosition called - forcing position (0,0)");
+
+    SDL_LockMutex(Android_ActivityMutex);
+
+    if (window == Android_Window) {
+        /* Always reset to origin */
+        window->x = 0;
+        window->y = 0;
+
+        __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "✅ Window position forced to (0,0)");
+    }
+
+    SDL_UnlockMutex(Android_ActivityMutex);
+}
+
 void Android_DestroyWindow(_THIS, SDL_Window *window)
 {
     SDL_LockMutex(Android_ActivityMutex);
diff --git a/src/video/android/SDL_androidwindow.h b/src/video/android/SDL_androidwindow.h
index 240c77c..5d9be1e 100644
--- a/src/video/android/SDL_androidwindow.h
+++ b/src/video/android/SDL_androidwindow.h
@@ -31,6 +31,8 @@ extern void Android_SetWindowTitle(_THIS, SDL_Window *window);
 extern void Android_SetWindowFullscreen(_THIS, SDL_Window *window, SDL_VideoDisplay *display, SDL_bool fullscreen);
 extern void Android_MinimizeWindow(_THIS, SDL_Window *window);
 extern void Android_SetWindowResizable(_THIS, SDL_Window *window, SDL_bool resizable);
+extern void Android_SetWindowSize(_THIS, SDL_Window *window);
+extern void Android_SetWindowPosition(_THIS, SDL_Window *window);
 
 extern void Android_DestroyWindow(_THIS, SDL_Window *window);
 extern SDL_bool Android_GetWindowWMInfo(_THIS, SDL_Window *window, struct SDL_SysWMinfo *info);
