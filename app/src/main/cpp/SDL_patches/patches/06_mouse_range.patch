diff --git a/../../SDL_original_2301/src/events/SDL_mouse.c b/../../SDL/src/events/SDL_mouse.c
index 431354f88..31059356e 100644
--- a/../../SDL_original_2301/src/events/SDL_mouse.c
+++ b/../../SDL/src/events/SDL_mouse.c
@@ -44,6 +44,15 @@ static SDL_Mouse SDL_mouse;
 /* for mapping mouse events to touch */
 static SDL_bool track_mouse_down = SDL_FALSE;
 
+/* Virtual mouse range limit (for game controls) */
+static SDL_bool g_vm_range_enabled = SDL_FALSE;
+static int g_vm_screen_width = 1920;
+static int g_vm_screen_height = 1080;
+static float g_vm_range_left = 1.0f;
+static float g_vm_range_top = 1.0f;
+static float g_vm_range_right = 1.0f;
+static float g_vm_range_bottom = 1.0f;
+
 static int SDL_PrivateSendMouseMotion(SDL_Window *window, SDL_MouseID mouseID, int relative, int x, int y);
 
 static void SDLCALL SDL_MouseDoubleClickTimeChanged(void *userdata, const char *name, const char *oldValue, const char *hint)
@@ -782,7 +791,17 @@ static int SDL_PrivateSendMouseButton(SDL_Window *window, SDL_MouseID mouseID, U
         SDL_UpdateMouseFocus(window, mouse->x, mouse->y, buttonstate, SDL_TRUE);
     }
 
-    if (buttonstate == source->buttonstate) {
+    /* RALCore: For multi-touch mouse emulation, skip state check when SDL_TOUCH_MOUSE_MULTITOUCH=1
+     * This allows multiple simultaneous touch points to each generate mouse events */
+    SDL_bool skip_state_check = SDL_FALSE;
+    if (mouseID == SDL_TOUCH_MOUSEID) {
+        const char* multitouch_hint = SDL_GetHint("SDL_TOUCH_MOUSE_MULTITOUCH");
+        if (multitouch_hint && SDL_strcmp(multitouch_hint, "1") == 0) {
+            skip_state_check = SDL_TRUE;
+        }
+    }
+
+    if (!skip_state_check && buttonstate == source->buttonstate) {
         /* Ignore this event, no state change */
         return 0;
     }
@@ -1501,4 +1520,48 @@ int SDL_ShowCursor(int toggle)
     return shown;
 }
 
+/* Virtual mouse range limit functions (for game controls) - exported */
+DECLSPEC void SDLCALL SDL_SetVirtualMouseRangeEnabled(SDL_bool enabled)
+{
+    g_vm_range_enabled = enabled;
+}
+
+DECLSPEC void SDLCALL SDL_SetVirtualMouseScreenSize(int width, int height)
+{
+    g_vm_screen_width = width > 0 ? width : 1920;
+    g_vm_screen_height = height > 0 ? height : 1080;
+}
+
+DECLSPEC void SDLCALL SDL_SetVirtualMouseRange(float left, float top, float right, float bottom)
+{
+    g_vm_range_left = left;
+    g_vm_range_top = top;
+    g_vm_range_right = right;
+    g_vm_range_bottom = bottom;
+}
+
+/* Apply range limit to coordinates - exported for virtual mouse usage */
+DECLSPEC void SDLCALL SDL_ApplyVirtualMouseRangeLimit(int *mouseX, int *mouseY)
+{
+    float centerX, centerY;
+    int minX, maxX, minY, maxY;
+    
+    if (!g_vm_range_enabled) {
+        return;
+    }
+    
+    centerX = g_vm_screen_width * 0.5f;
+    centerY = g_vm_screen_height * 0.5f;
+    
+    minX = (int)(centerX - (g_vm_range_left * centerX));
+    maxX = (int)(centerX + (g_vm_range_right * centerX));
+    minY = (int)(centerY - (g_vm_range_top * centerY));
+    maxY = (int)(centerY + (g_vm_range_bottom * centerY));
+    
+    if (*mouseX < minX) *mouseX = minX;
+    if (*mouseX > maxX) *mouseX = maxX;
+    if (*mouseY < minY) *mouseY = minY;
+    if (*mouseY > maxY) *mouseY = maxY;
+}
+
 /* vi: set ts=4 sw=4 expandtab: */
