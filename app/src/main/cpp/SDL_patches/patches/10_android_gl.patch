warning: in the working copy of 'app/src/main/cpp/SDL_patches/patches/../../SDL/src/video/android/SDL_androidgl.c', LF will be replaced by CRLF the next time Git touches it
diff --git a/../../SDL_original_2301/src/video/android/SDL_androidgl.c b/../../SDL/src/video/android/SDL_androidgl.c
index 5e5ef603e..8d881ca2a 100644
--- a/../../SDL_original_2301/src/video/android/SDL_androidgl.c
+++ b/../../SDL/src/video/android/SDL_androidgl.c
@@ -22,6 +22,8 @@
 
 #if defined(SDL_VIDEO_DRIVER_ANDROID) && defined(SDL_VIDEO_OPENGL_EGL)
 
+#include <unistd.h> // for usleep
+
 /* Android SDL video driver implementation */
 
 #include "SDL_video.h"
@@ -33,12 +35,216 @@
 #include "../../core/android/SDL_android.h"
 
 #include <android/log.h>
+#include <android/native_window.h>
 
 #include <dlfcn.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <time.h>
+#include "../../SDL_internal.h"  // SDL_bool is defined here
+#include "SDL_androidwindow.h"  // For SDL_WindowData
+
+/* FPS 璁＄畻鐩稿叧 - 浣跨敤婊戝姩绐楀彛骞冲潎瀹炵幇绮惧噯绋冲畾鐨勬娴?*/
+#define FPS_SAMPLE_COUNT 30  /* 婊戝姩绐楀彛澶у皬锛堝抚鏁帮級- 鍑忓皬浠ユ彁楂樺搷搴旈€熷害 */
+#define FPS_UPDATE_INTERVAL_NS 100000000LL  /* 鏇存柊闂撮殧 100ms锛堢撼绉掞級- 鏇撮绻佹洿鏂?*/
+
+static Uint64 g_frame_times[FPS_SAMPLE_COUNT] = {0};  /* 甯ф椂闂存埑鐜舰缂撳啿 */
+static int g_frame_index = 0;                          /* 褰撳墠甯х储寮?*/
+static int g_frame_count = 0;                          /* 鏈夋晥甯ц鏁?*/
+static Uint64 g_last_update_ns = 0;                    /* 涓婃鏇存柊鏃堕棿 */
+static float g_fps_current = 0.0f;                     /* 褰撳墠 FPS */
+static float g_fps_smoothed = 0.0f;                    /* 骞虫粦鍚庣殑 FPS */
+static float g_frame_time_ms = 0.0f;                   /* 骞冲潎甯ф椂闂?*/
+static char g_fps_env_buffer[64] = {0};
+static SDL_bool g_fps_initialized = SDL_FALSE;
+
+/* 鑾峰彇褰撳墠鏃堕棿锛堢撼绉掔骇绮惧害锛?*/
+static Uint64 GetTimeNS(void)
+{
+    struct timespec ts;
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    return (Uint64)ts.tv_sec * 1000000000ULL + (Uint64)ts.tv_nsec;
+}
+
+/* 鍒濆鍖?FPS 杩借釜 */
+static void InitFPSTracking(void)
+{
+    if (g_fps_initialized) return;
+    g_fps_initialized = SDL_TRUE;
+    
+    SDL_memset(g_frame_times, 0, sizeof(g_frame_times));
+    g_frame_index = 0;
+    g_frame_count = 0;
+    g_last_update_ns = GetTimeNS();
+    g_fps_current = 0.0f;
+    g_fps_smoothed = 0.0f;
+    
+    setenv("RAL_FPS", "0", 1);
+    setenv("RAL_FRAME_TIME", "0", 1);
+    
+    __android_log_print(ANDROID_LOG_INFO, "SDL_FPS", 
+        "FPS tracking initialized (sample window: %d frames)", FPS_SAMPLE_COUNT);
+}
+
+/* 鏇存柊 FPS - 浣跨敤婊戝姩绐楀彛骞冲潎 */
+static void UpdateFPS(void)
+{
+    Uint64 current_ns = GetTimeNS();
+    
+    /* 璁板綍甯ф椂闂村埌鐜舰缂撳啿 */
+    g_frame_times[g_frame_index] = current_ns;
+    g_frame_index = (g_frame_index + 1) % FPS_SAMPLE_COUNT;
+    if (g_frame_count < FPS_SAMPLE_COUNT) {
+        g_frame_count++;
+    }
+    
+    /* 妫€鏌ユ槸鍚﹂渶瑕佹洿鏂?FPS 鏄剧ず */
+    Uint64 elapsed_ns = current_ns - g_last_update_ns;
+    if (elapsed_ns < FPS_UPDATE_INTERVAL_NS) {
+        return;
+    }
+    g_last_update_ns = current_ns;
+    
+    /* 璁＄畻婊戝姩绐楀彛鍐呯殑骞冲潎 FPS */
+    if (g_frame_count >= 2) {
+        /* 鎵惧埌绐楀彛鍐呮渶鑰佺殑甯?*/
+        int oldest_index = (g_frame_index - g_frame_count + FPS_SAMPLE_COUNT) % FPS_SAMPLE_COUNT;
+        int newest_index = (g_frame_index - 1 + FPS_SAMPLE_COUNT) % FPS_SAMPLE_COUNT;
+        
+        Uint64 oldest_time = g_frame_times[oldest_index];
+        Uint64 newest_time = g_frame_times[newest_index];
+        
+        if (newest_time > oldest_time) {
+            Uint64 window_duration_ns = newest_time - oldest_time;
+            int frame_intervals = g_frame_count - 1;
+            
+            /* 璁＄畻 FPS: (甯ф暟-1) / 鏃堕棿绐楀彛 */
+            g_fps_current = (float)frame_intervals * 1000000000.0f / (float)window_duration_ns;
+            
+            /* 璁＄畻骞冲潎甯ф椂闂?(ms) */
+            g_frame_time_ms = (float)window_duration_ns / (float)frame_intervals / 1000000.0f;
+            
+            /* 鎸囨暟绉诲姩骞冲潎骞虫粦 (EMA)锛宎lpha = 0.5 - 鏇村揩鍝嶅簲 */
+            if (g_fps_smoothed <= 0.0f) {
+                g_fps_smoothed = g_fps_current;
+            } else {
+                g_fps_smoothed = g_fps_smoothed * 0.5f + g_fps_current * 0.5f;
+            }
+        }
+    }
+    
+    /* 閫氳繃鐜鍙橀噺浼犻€掔粰 Java */
+    SDL_snprintf(g_fps_env_buffer, sizeof(g_fps_env_buffer), "%.1f", g_fps_smoothed);
+    setenv("RAL_FPS", g_fps_env_buffer, 1);
+    
+    SDL_snprintf(g_fps_env_buffer, sizeof(g_fps_env_buffer), "%.2f", g_frame_time_ms);
+    setenv("RAL_FRAME_TIME", g_fps_env_buffer, 1);
+}
 
 int Android_GLES_MakeCurrent(_THIS, SDL_Window *window, SDL_GLContext context)
 {
     if (window && context) {
+        /* For OSMesa zink, create OSMesa context when SDL context is made current
+         * This ensures OSMesa context is ready before FNA3D calls glGetString()
+         */
+#ifdef __ANDROID__
+        const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+        SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+            "MakeCurrent: FNA3D_OPENGL_LIBRARY=%s, is_osmesa=%d",
+            fna3d_gl_lib ? fna3d_gl_lib : "(null)", is_osmesa);
+
+        if (is_osmesa) {
+            /* Try to load osm_renderer_init from the main library using dlopen/dlsym
+             * Try multiple possible library names
+             */
+            static bool osm_initialized = false;
+            if (!osm_initialized) {
+                const char* lib_names[] = {"libralaunch.so", "libmain.so", NULL};
+                void *main_lib = NULL;
+                int i = 0;
+
+                while (lib_names[i] != NULL && main_lib == NULL) {
+                    main_lib = dlopen(lib_names[i], RTLD_LAZY | RTLD_LOCAL);
+                    if (main_lib) {
+                        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                            "鉁?Loaded library: %s", lib_names[i]);
+                    } else {
+                        __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                            "鈿?Failed to load %s: %s", lib_names[i], dlerror());
+                    }
+                    i++;
+                }
+
+                if (main_lib) {
+                    typedef bool (*osm_renderer_init_func)(ANativeWindow*);
+                    typedef bool (*osm_renderer_is_available_func)(void);
+                    typedef bool (*osm_renderer_is_initialized_func)(void);
+
+                    osm_renderer_is_available_func osm_is_available = (osm_renderer_is_available_func)
+                        dlsym(main_lib, "osm_renderer_is_available");
+                    osm_renderer_is_initialized_func osm_is_initialized = (osm_renderer_is_initialized_func)
+                        dlsym(main_lib, "osm_renderer_is_initialized");
+                    osm_renderer_init_func osm_init = (osm_renderer_init_func)
+                        dlsym(main_lib, "osm_renderer_init");
+
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "OSMesa function pointers: is_available=%p, is_initialized=%p, init=%p",
+                        osm_is_available, osm_is_initialized, osm_init);
+
+                    if (osm_is_available && osm_is_initialized && osm_init) {
+                        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                            "All OSMesa functions loaded successfully");
+
+                        if (osm_is_available() && !osm_is_initialized()) {
+                            SDL_WindowData *data = (SDL_WindowData *)window->driverdata;
+                            ANativeWindow *native_window = data->native_window;
+
+                            if (native_window != NULL) {
+                                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                                    "Creating OSMesa context when SDL context is made current...");
+                                if (osm_init(native_window)) {
+                                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                                        "鉁?OSMesa context created and made current");
+
+                                    // CRITICAL: Wait a bit for OSMesa context to be fully ready
+                                    // This ensures glGetString() will work when FNA3D initializes
+                                    // zink needs time to initialize the Vulkan device and OpenGL context
+                                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                                        "Waiting for OSMesa context to be fully ready...");
+                                    usleep(150000); // 150ms delay for zink initialization
+
+                                    osm_initialized = true;
+                                } else {
+                                    __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                                        "鈿?Failed to create OSMesa context, will use EGL fallback");
+                                }
+                            } else {
+                                __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                                    "鈿?Native window is NULL, cannot create OSMesa context");
+                            }
+                        } else if (osm_is_initialized()) {
+                            osm_initialized = true;
+                        }
+                    } else {
+                        __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                            "鈿?Failed to load OSMesa functions from library");
+                    }
+                    // Don't close main_lib, we need the symbols to remain available
+                } else {
+                    __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                        "鈿?Failed to load any OSMesa-compatible library");
+                }
+            }
+
+            /* For OSMesa, don't call SDL_EGL_MakeCurrent - OSMesa manages its own context */
+            __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                "OSMesa mode: returning success without EGL MakeCurrent");
+            return 0;
+        }
+#endif
         return SDL_EGL_MakeCurrent(_this, ((SDL_WindowData *)window->driverdata)->egl_surface, context);
     } else {
         return SDL_EGL_MakeCurrent(_this, NULL, NULL);
@@ -51,6 +257,23 @@ SDL_GLContext Android_GLES_CreateContext(_THIS, SDL_Window *window)
 
     Android_ActivityMutex_Lock_Running();
 
+#ifdef __ANDROID__
+    /* For OSMesa, return a dummy context since OSMesa manages its own OpenGL context */
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    if (is_osmesa) {
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+            "OSMesa detected, returning dummy GL context (OSMesa manages its own context)");
+        /* Return a non-NULL dummy pointer to indicate success
+         * OSMesa context is managed separately via osm_init_context()
+         * We use (void*)1 as a sentinel value to indicate "OSMesa mode"
+         */
+        SDL_UnlockMutex(Android_ActivityMutex);
+        return (SDL_GLContext)(void*)1;
+    }
+#endif
+
     ret = SDL_EGL_CreateContext(_this, ((SDL_WindowData *)window->driverdata)->egl_surface);
 
     SDL_UnlockMutex(Android_ActivityMutex);
@@ -62,8 +285,47 @@ int Android_GLES_SwapWindow(_THIS, SDL_Window *window)
 {
     int retval;
 
+    /* 鍒濆鍖栧苟鏇存柊 FPS锛堟粦鍔ㄧ獥鍙ｅ钩鍧囩畻娉曪級 */
+    InitFPSTracking();
+    UpdateFPS();
+
     SDL_LockMutex(Android_ActivityMutex);
 
+#ifdef __ANDROID__
+    /* For OSMesa/zink rendering, use OSMesa swap buffers instead of EGL
+     * OSMesa renders to a software buffer that needs to be copied to the native window
+     */
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    if (is_osmesa) {
+        /* Try to call osm_swap_buffers from the main library */
+        static void (*osm_swap_buffers_fn)(void) = NULL;
+        static SDL_bool osm_swap_init_attempted = SDL_FALSE;
+
+        if (!osm_swap_init_attempted) {
+            osm_swap_init_attempted = SDL_TRUE;
+            void* main_lib = dlopen("libmain.so", RTLD_LAZY | RTLD_LOCAL);
+            if (main_lib) {
+                osm_swap_buffers_fn = (void (*)(void)) dlsym(main_lib, "osm_swap_buffers");
+                if (osm_swap_buffers_fn) {
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "鉁?Found osm_swap_buffers function for OSMesa rendering");
+                }
+            }
+        }
+
+        if (osm_swap_buffers_fn) {
+            osm_swap_buffers_fn();
+            SDL_UnlockMutex(Android_ActivityMutex);
+            return 0;
+        } else {
+            __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                "鈿?osm_swap_buffers not found, falling back to EGL swap");
+        }
+    }
+#endif
+
     /* The following two calls existed in the original Java code
      * If you happen to have a device that's affected by their removal,
      * please report to our bug tracker. -- Gabriel
@@ -77,12 +339,257 @@ int Android_GLES_SwapWindow(_THIS, SDL_Window *window)
 
     return retval;
 }
-
 int Android_GLES_LoadLibrary(_THIS, const char *path)
 {
+    const char* custom_egl_path = NULL;
+    const char* current_renderer = NULL;
+    const char* egl_lib_path = NULL;
+
+    __android_log_print(ANDROID_LOG_INFO, "Android_GLES", "Android_GLES_LoadLibrary called, path=%s", path ? path : "(null)");
+
+    /* 妫€鏌ユ槸鍚﹀凡缁忛€氳繃 Android_LoadRenderer() 棰勫姞杞戒簡娓叉煋鍣?+     * 濡傛灉宸查鍔犺浇锛岄渶瑕佷紶閫掑簱璺緞璁?SDL_EGL_LoadLibrary 浣跨敤璇ュ簱
+     */
+    #ifdef SDL_VIDEO_DRIVER_ANDROID
+    extern const char* Android_GetCurrentRenderer(void);
+    extern const char* Android_GetCurrentRendererLibPath(void);
+
+    current_renderer = Android_GetCurrentRenderer();
+    egl_lib_path = Android_GetCurrentRendererLibPath();
+
+    __android_log_print(ANDROID_LOG_INFO, "Android_GLES", "current_renderer = %s, egl_lib_path = %s",
+                        current_renderer ? current_renderer : "(null)",
+                        egl_lib_path ? egl_lib_path : "(null)");
+
+    if (current_renderer && SDL_strcmp(current_renderer, "native") != 0 && SDL_strcmp(current_renderer, "none") != 0) {
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "Renderer '%s' already preloaded", current_renderer);
+
+        /* 妫€鏌ユ槸鍚︽槸 OSMesa 娓叉煋鍣紙zink/virgl 绛夛級
+         * OSMesa 娓叉煋鍣ㄩ渶瑕佷娇鐢?OSMesa 搴撹矾寰?+         * 鍏朵粬娓叉煋鍣紙gl4es 绛夛級浣跨敤绯荤粺 EGL + 鑷畾涔?GL 搴?+         */
+        const char* fna3d_ogl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+        SDL_bool is_osmesa = (fna3d_ogl_lib && SDL_strcasestr(fna3d_ogl_lib, "osmesa"));
+
+        // 妫€鏌ユ槸鍚︽槸 zink 娓叉煋鍣?+        const char *fna3d_driver = SDL_getenv("FNA3D_OPENGL_DRIVER");
+        SDL_bool is_zink = (current_renderer && (SDL_strcmp(current_renderer, "zink") == 0 ||
+                                                 SDL_strstr(current_renderer, "vulkan_zink") != NULL)) ||
+                           (fna3d_driver && SDL_strcasecmp(fna3d_driver, "zink") == 0);
+
+        if (is_zink) {
+            __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "Zink renderer detected, checking Vulkan availability...");
+
+            /* 妫€鏌?VULKAN_PTR 鐜鍙橀噺锛堢敱 Java 灞傝缃級 */
+            const char* vulkan_ptr = SDL_getenv("VULKAN_PTR");
+            if (vulkan_ptr != NULL && vulkan_ptr[0] != '\0') {
+                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                            "鉁?Vulkan library already loaded (VULKAN_PTR=%s)", vulkan_ptr);
+            } else {
+                /* 濡傛灉 Java 灞傛病鏈夊姞杞斤紝灏濊瘯鍦ㄨ繖閲屽姞杞?*/
+                __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                            "鈿?VULKAN_PTR not set, attempting to load Vulkan...");
+                void* vulkan_handle = dlopen("libvulkan.so", RTLD_LAZY | RTLD_LOCAL);
+                if (vulkan_handle != NULL) {
+                    char envval[64];
+                    SDL_snprintf(envval, sizeof(envval), "%p", vulkan_handle);
+                    SDL_setenv("VULKAN_PTR", envval, 1);
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                                "鉁?Vulkan library loaded: %s", envval);
+                } else {
+                    __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                                "鈿?Failed to load Vulkan library: %s", dlerror());
+                }
+            }
+        }
+
+        /* 瀵逛簬 OSMesa 娓叉煋鍣紝浼犻€?OSMesa 搴撹矾寰勭粰 SDL_EGL_LoadLibrary
+         * OSMesa 涓嶄娇鐢ㄧ湡姝ｇ殑 EGL锛屼絾闇€瑕佸姞杞藉簱浠ヨ幏鍙?GL 鍑芥暟
+         */
+        if (is_osmesa && fna3d_ogl_lib) {
+            __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "OSMesa renderer: Using OSMesa library: %s", fna3d_ogl_lib);
+            return SDL_EGL_LoadLibrary(_this, fna3d_ogl_lib, (NativeDisplayType)0, 0);
+        }
+
+        /* 瀵逛簬闈?OSMesa 娓叉煋鍣紙gl4es 绛夛級锛屼娇鐢ㄧ郴缁?EGL
+         * GL 鍑芥暟灏嗛€氳繃 eglGetProcAddress 鎴?dlsym 浠庨鍔犺浇鐨?GL 搴撹幏鍙?+         */
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "Non-OSMesa renderer '%s': Using system EGL with preloaded GL library",
+                    current_renderer);
+        return SDL_EGL_LoadLibrary(_this, egl_lib_path, (NativeDisplayType)0, 0);
+    }
+    #endif
+
+    /* 妫€鏌ユ槸鍚﹂€氳繃 FNA3D_OPENGL_LIBRARY 鐜鍙橀噺鎸囧畾浜嗚嚜瀹氫箟 EGL 搴?+     * 浣跨敤鐜鍙橀噺鎸囧畾搴撹矾寰勭粫杩?Android 閾炬帴鍣ㄥ懡鍚嶇┖闂撮檺鍒?+     */
+    custom_egl_path = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+
+    if (custom_egl_path != NULL && custom_egl_path[0] != '\0') {
+        SDL_LogInfo(SDL_LOG_CATEGORY_VIDEO,
+                    "Android_GLES_LoadLibrary: Using custom EGL from FNA3D_OPENGL_LIBRARY: %s",
+                    custom_egl_path);
+        return SDL_EGL_LoadLibrary(_this, custom_egl_path, (NativeDisplayType)0, 0);
+    }
+
+    /* 鍥為€€鍒伴粯璁よ涓?浣跨敤绯荤粺 libEGL.so) */
     return SDL_EGL_LoadLibrary(_this, path, (NativeDisplayType)0, 0);
 }
 
+void *Android_GLES_GetProcAddress(_THIS, const char *proc)
+{
+#ifdef __ANDROID__
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    /* For OSMesa, use OSMesaGetProcAddress */
+    if (is_osmesa) {
+        static void* (*OSMesaGetProcAddress_fn)(const char*) = NULL;
+        static SDL_bool osmesa_proc_init_attempted = SDL_FALSE;
+        static int log_count = 0;
+
+        if (!osmesa_proc_init_attempted) {
+            osmesa_proc_init_attempted = SDL_TRUE;
+            void* osmesa_lib = dlopen(fna3d_gl_lib, RTLD_LAZY | RTLD_LOCAL);
+            if (osmesa_lib) {
+                OSMesaGetProcAddress_fn = (void* (*)(const char*)) dlsym(osmesa_lib, "OSMesaGetProcAddress");
+                if (OSMesaGetProcAddress_fn) {
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "鉁?OSMesaGetProcAddress loaded for GL function lookup from %s", fna3d_gl_lib);
+                } else {
+                    __android_log_print(ANDROID_LOG_ERROR, "Android_GLES",
+                        "鉁?OSMesaGetProcAddress NOT found in %s", fna3d_gl_lib);
+                }
+            } else {
+                __android_log_print(ANDROID_LOG_ERROR, "Android_GLES",
+                    "鉁?Failed to dlopen OSMesa library: %s - %s", fna3d_gl_lib, dlerror());
+            }
+        }
+
+        if (OSMesaGetProcAddress_fn) {
+            void* result = OSMesaGetProcAddress_fn(proc);
+            if (log_count < 20) {
+                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "GetProcAddress(%s) -> OSMesa: %p", proc, result);
+                log_count++;
+            }
+            if (result) {
+                return result;
+            }
+            __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                "OSMesaGetProcAddress returned NULL for %s, falling back to EGL", proc);
+        }
+    }
+
+    /* For custom GL libraries (gl4es, etc.), try dlsym first
+     * These libraries provide their own GL implementations
+     */
+    if (fna3d_gl_lib && !is_osmesa) {
+        static void* custom_gl_lib = NULL;
+        static SDL_bool custom_gl_init_attempted = SDL_FALSE;
+        static int custom_log_count = 0;
+
+        if (!custom_gl_init_attempted) {
+            custom_gl_init_attempted = SDL_TRUE;
+            /* Open with RTLD_NOLOAD to get the already-loaded library handle */
+            custom_gl_lib = dlopen(fna3d_gl_lib, RTLD_LAZY | RTLD_NOLOAD);
+            if (!custom_gl_lib) {
+                /* Try opening it normally */
+                custom_gl_lib = dlopen(fna3d_gl_lib, RTLD_LAZY | RTLD_LOCAL);
+            }
+            if (custom_gl_lib) {
+                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "鉁?Custom GL library loaded for function lookup: %s", fna3d_gl_lib);
+            } else {
+                __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                    "鈿?Failed to load custom GL library: %s - %s", fna3d_gl_lib, dlerror());
+            }
+        }
+
+        if (custom_gl_lib) {
+            void* result = dlsym(custom_gl_lib, proc);
+            if (result) {
+                if (custom_log_count < 20) {
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "GetProcAddress(%s) -> Custom GL: %p", proc, result);
+                    custom_log_count++;
+                }
+                return result;
+            }
+            /* Fall through to EGL if custom library doesn't have the function */
+        }
+    }
+#endif
+    return SDL_EGL_GetProcAddress(_this, proc);
+}
+
+void Android_GLES_UnloadLibrary(_THIS)
+{
+    SDL_EGL_UnloadLibrary(_this);
+}
+
+int Android_GLES_SetSwapInterval(_THIS, int interval)
+{
+    return SDL_EGL_SetSwapInterval(_this, interval);
+}
+
+int Android_GLES_GetSwapInterval(_THIS)
+{
+    return SDL_EGL_GetSwapInterval(_this);
+}
+
+void Android_GLES_DeleteContext(_THIS, SDL_GLContext context)
+{
+#ifdef __ANDROID__
+    /* For OSMesa, the context is a dummy pointer - don't call EGL delete */
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    if (is_osmesa) {
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+            "OSMesa mode: skipping EGL DeleteContext (OSMesa manages its own context)");
+        return;
+    }
+#endif
+    SDL_EGL_DeleteContext(_this, context);
+}
+
+void Android_GLES_GetDrawableSize(_THIS, SDL_Window *window, int *w, int *h)
+{
+#ifdef __ANDROID__
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    if (is_osmesa) {
+        /* For OSMesa, get the drawable size from the native window */
+        SDL_WindowData *data = (SDL_WindowData *)window->driverdata;
+        if (data && data->native_window) {
+            int native_w = ANativeWindow_getWidth(data->native_window);
+            int native_h = ANativeWindow_getHeight(data->native_window);
+            if (native_w > 0 && native_h > 0) {
+                if (w) *w = native_w;
+                if (h) *h = native_h;
+                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "OSMesa GetDrawableSize: %dx%d (from ANativeWindow)", native_w, native_h);
+                return;
+            }
+        }
+        /* Fall back to window size */
+        if (w) *w = window->w;
+        if (h) *h = window->h;
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+            "OSMesa GetDrawableSize: %dx%d (fallback to window size)", window->w, window->h);
+        return;
+    }
+#endif
+    /* Default: use window size in pixels */
+    SDL_GetWindowSizeInPixels(window, w, h);
+}
+
 #endif /* SDL_VIDEO_DRIVER_ANDROID */
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/../../SDL_original_2301/src/video/android/SDL_androidgl.h b/../../SDL/src/video/android/SDL_androidgl.h
index 4fb505c1f..e0fbf3597 100644
--- a/../../SDL_original_2301/src/video/android/SDL_androidgl.h
+++ b/../../SDL/src/video/android/SDL_androidgl.h
@@ -23,10 +23,16 @@
 #ifndef SDL_androidgl_h_
 #define SDL_androidgl_h_
 
+int Android_GLES_LoadLibrary(_THIS, const char *path);
+void *Android_GLES_GetProcAddress(_THIS, const char *proc);
+void Android_GLES_UnloadLibrary(_THIS);
 SDL_GLContext Android_GLES_CreateContext(_THIS, SDL_Window *window);
 int Android_GLES_MakeCurrent(_THIS, SDL_Window *window, SDL_GLContext context);
+int Android_GLES_SetSwapInterval(_THIS, int interval);
+int Android_GLES_GetSwapInterval(_THIS);
 int Android_GLES_SwapWindow(_THIS, SDL_Window *window);
-int Android_GLES_LoadLibrary(_THIS, const char *path);
+void Android_GLES_DeleteContext(_THIS, SDL_GLContext context);
+void Android_GLES_GetDrawableSize(_THIS, SDL_Window *window, int *w, int *h);
 
 #endif /* SDL_androidgl_h_ */
 
