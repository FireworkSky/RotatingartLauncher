diff --git a/../../SDL_original_2301/src/events/SDL_touch.c b/../../SDL/src/events/SDL_touch.c
index b5ec77bd5..ef50f2c0f 100644
--- a/../../SDL_original_2301/src/events/SDL_touch.c
+++ b/../../SDL/src/events/SDL_touch.c
@@ -23,9 +23,15 @@
 /* General touch handling code for SDL */
 
 #include "SDL_events.h"
+#include "SDL_hints.h"
+#include "SDL_timer.h"
 #include "SDL_events_c.h"
 #include "../video/SDL_sysvideo.h"
 
+#ifdef __ANDROID__
+#include <android/log.h>
+#endif
+
 static int SDL_num_touch = 0;
 static SDL_Touch **SDL_touchDevices = NULL;
 
@@ -37,6 +43,104 @@ static SDL_Touch **SDL_touchDevices = NULL;
 static SDL_bool finger_touching = SDL_FALSE;
 static SDL_FingerID track_fingerid;
 static SDL_TouchID track_touchid;
+
+/* Multi-touch support for mouse emulation (RALCore extension)
+ * 
+ * When SDL_TOUCH_MOUSE_MULTITOUCH=1:
+ * - Each finger independently sends mouse button events
+ * - SDL_mouse.c's state check is bypassed to allow duplicate button events
+ * - The most recently touched finger controls mouse cursor movement
+ */
+#define MAX_TRACKED_FINGERS 10
+static int multitouch_finger_count = 0;
+static SDL_FingerID multitouch_fingers[MAX_TRACKED_FINGERS];
+static float multitouch_finger_x[MAX_TRACKED_FINGERS];
+static float multitouch_finger_y[MAX_TRACKED_FINGERS];
+static SDL_bool multitouch_enabled = SDL_FALSE;
+static SDL_FingerID multitouch_active_finger = 0;
+
+/* 琚櫄鎷熸帶浠跺崰鐢ㄧ殑瑙︽懜鐐癸紙涓嶅弬涓庤Е灞忚浆榧犳爣锛?*/
+#define MAX_CONSUMED_FINGERS 10
+static int consumed_finger_count = 0;
+static int consumed_fingers[MAX_CONSUMED_FINGERS];
+
+/* 妫€鏌ヨЕ鎽哥偣鏄惁琚櫄鎷熸帶浠跺崰鐢?*/
+static SDL_bool SDL_IsFingerConsumed(int fingerId) {
+    for (int i = 0; i < consumed_finger_count; i++) {
+        if (consumed_fingers[i] == fingerId) return SDL_TRUE;
+    }
+    return SDL_FALSE;
+}
+
+/* 鏍囪瑙︽懜鐐硅铏氭嫙鎺т欢鍗犵敤锛堢敱 Java 灞傝皟鐢級 */
+void SDL_ConsumeFingerTouch(int fingerId) {
+    if (consumed_finger_count >= MAX_CONSUMED_FINGERS) return;
+    if (SDL_IsFingerConsumed(fingerId)) return;
+    consumed_fingers[consumed_finger_count++] = fingerId;
+#ifdef __ANDROID__
+    /* Reduced logging */
+    #if 0
+    __android_log_print(ANDROID_LOG_VERBOSE, "SDLTouch", "Finger %d consumed by virtual control", fingerId);
+    #endif
+#endif
+}
+
+/* 閲婃斁琚櫄鎷熸帶浠跺崰鐢ㄧ殑瑙︽懜鐐癸紙鐢?Java 灞傝皟鐢級 */
+void SDL_ReleaseFingerTouch(int fingerId) {
+    for (int i = 0; i < consumed_finger_count; i++) {
+        if (consumed_fingers[i] == fingerId) {
+            for (int j = i; j < consumed_finger_count - 1; j++) {
+                consumed_fingers[j] = consumed_fingers[j + 1];
+            }
+            consumed_finger_count--;
+#ifdef __ANDROID__
+            __android_log_print(ANDROID_LOG_INFO, "SDLTouch", "Finger %d released", fingerId);
+#endif
+            return;
+        }
+    }
+}
+
+/* 娓呴櫎鎵€鏈夊崰鐢ㄧ殑瑙︽懜鐐?*/
+void SDL_ClearConsumedFingers(void) {
+    consumed_finger_count = 0;
+#ifdef __ANDROID__
+    __android_log_print(ANDROID_LOG_INFO, "SDLTouch", "All consumed fingers cleared");
+#endif
+}
+
+static int SDL_FindMultitouchFinger(SDL_FingerID fingerid) {
+    for (int i = 0; i < multitouch_finger_count; i++) {
+        if (multitouch_fingers[i] == fingerid) return i;
+    }
+    return -1;
+}
+
+static void SDL_AddMultitouchFinger(SDL_FingerID fingerid, float x, float y) {
+    if (multitouch_finger_count >= MAX_TRACKED_FINGERS) return;
+    multitouch_fingers[multitouch_finger_count] = fingerid;
+    multitouch_finger_x[multitouch_finger_count] = x;
+    multitouch_finger_y[multitouch_finger_count] = y;
+    multitouch_finger_count++;
+}
+
+static void SDL_RemoveMultitouchFinger(SDL_FingerID fingerid) {
+    int idx = SDL_FindMultitouchFinger(fingerid);
+    if (idx < 0) return;
+    for (int i = idx; i < multitouch_finger_count - 1; i++) {
+        multitouch_fingers[i] = multitouch_fingers[i + 1];
+        multitouch_finger_x[i] = multitouch_finger_x[i + 1];
+        multitouch_finger_y[i] = multitouch_finger_y[i + 1];
+    }
+    multitouch_finger_count--;
+}
+
+static void SDL_UpdateMultitouchFinger(SDL_FingerID fingerid, float x, float y) {
+    int idx = SDL_FindMultitouchFinger(fingerid);
+    if (idx < 0) return;
+    multitouch_finger_x[idx] = x;
+    multitouch_finger_y[idx] = y;
+}
 #endif
 
 /* Public functions */
@@ -248,51 +352,157 @@ int SDL_SendTouch(SDL_TouchID id, SDL_FingerID fingerid, SDL_Window *window,
     mouse = SDL_GetMouse();
 
 #if SYNTHESIZE_TOUCH_TO_MOUSE
+    /* 妫€鏌ユ瑙︽懜鐐规槸鍚﹁铏氭嫙鎺т欢鍗犵敤锛堝铏氭嫙鎽囨潌锛?/
+    SDL_bool isConsumed = SDL_IsFingerConsumed((int)fingerid);
+#ifdef __ANDROID__
+    /* Reduced logging */
+    #if 0
+    if (isConsumed) {
+        __android_log_print(ANDROID_LOG_VERBOSE, "SDLTouchMouse", 
+            "Finger %d is consumed by virtual control, skipping mouse events", (int)fingerid);
+    }
+    #endif
+#endif
+    
+    /* Check for multitouch mode: SDL_TOUCH_MOUSE_MULTITOUCH=1 enables multi-finger gestures */
+    {
+        const char* multitouch_hint = SDL_GetHint("SDL_TOUCH_MOUSE_MULTITOUCH");
+        multitouch_enabled = (multitouch_hint && SDL_strcmp(multitouch_hint, "1") == 0);
+    }
+    
     /* SDL_HINT_TOUCH_MOUSE_EVENTS: controlling whether touch events should generate synthetic mouse events */
     /* SDL_HINT_VITA_TOUCH_MOUSE_DEVICE: controlling which touchpad should generate synthetic mouse events, PSVita-only */
+    /* 鍙湁鏈铏氭嫙鎺т欢鍗犵敤鐨勮Е鎽哥偣鎵嶄細鐢熸垚榧犳爣浜嬩欢 */
     {
 #if defined(__vita__)
-        if (mouse->touch_mouse_events && ((mouse->vita_touch_mouse_device == id) || (mouse->vita_touch_mouse_device == 2))) {
+        if (mouse->touch_mouse_events && !isConsumed && ((mouse->vita_touch_mouse_device == id) || (mouse->vita_touch_mouse_device == 2))) {
 #else
-        if (mouse->touch_mouse_events) {
+        if (mouse->touch_mouse_events && !isConsumed) {
 #endif
             /* FIXME: maybe we should only restrict to a few SDL_TouchDeviceType */
             if (id != SDL_MOUSE_TOUCHID) {
                 if (window) {
-                    if (down) {
-                        if (finger_touching == SDL_FALSE) {
+                    if (multitouch_enabled) {
+                        /* Multi-touch mode: each finger sends independent mouse events
+                         * SDL_mouse.c will skip state checking when multitouch is enabled
+                         */
+                        if (down) {
                             int pos_x = (int)(x * (float)window->w);
                             int pos_y = (int)(y * (float)window->h);
-                            if (pos_x < 0) {
-                                pos_x = 0;
+                            if (pos_x < 0) pos_x = 0;
+                            if (pos_x > window->w - 1) pos_x = window->w - 1;
+                            if (pos_y < 0) pos_y = 0;
+                            if (pos_y > window->h - 1) pos_y = window->h - 1;
+                            
+                            SDL_AddMultitouchFinger(fingerid, x, y);
+                            
+                            /* This finger becomes the active one (controls mouse movement) */
+                            multitouch_active_finger = fingerid;
+                            finger_touching = SDL_TRUE;
+                            track_touchid = id;
+                            track_fingerid = fingerid;
+                            
+                            /* Send mouse move and button press - state check bypassed in SDL_mouse.c */
+                            SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
+                            SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
+                        } else {
+                            /* Finger up */
+                            int finger_idx = SDL_FindMultitouchFinger(fingerid);
+                            SDL_bool is_active = (fingerid == multitouch_active_finger);
+                            
+                            /* Send release at this finger's position */
+                            if (finger_idx >= 0) {
+                                int pos_x = (int)(multitouch_finger_x[finger_idx] * (float)window->w);
+                                int pos_y = (int)(multitouch_finger_y[finger_idx] * (float)window->h);
+                                if (pos_x < 0) pos_x = 0;
+                                if (pos_x > window->w - 1) pos_x = window->w - 1;
+                                if (pos_y < 0) pos_y = 0;
+                                if (pos_y > window->h - 1) pos_y = window->h - 1;
+                                SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
+                                SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_RELEASED, SDL_BUTTON_LEFT);
                             }
-                            if (pos_x > window->w - 1) {
-                                pos_x = window->w - 1;
+                            
+                            SDL_RemoveMultitouchFinger(fingerid);
+                            
+                            if (is_active && multitouch_finger_count > 0) {
+                                /* Transfer active finger */
+                                multitouch_active_finger = multitouch_fingers[0];
+                                track_fingerid = multitouch_fingers[0];
+                            } else if (multitouch_finger_count == 0) {
+                                finger_touching = SDL_FALSE;
                             }
-                            if (pos_y < 0) {
-                                pos_y = 0;
+                        }
+                    } else {
+                        /* Original single-touch behavior */
+#ifdef __ANDROID__
+                        __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                            "Single-touch mode: down=%d finger_touching=%d finger=%lld track_finger=%lld",
+                            down, finger_touching, (long long)fingerid, (long long)track_fingerid);
+#endif
+                        if (down) {
+                            if (finger_touching == SDL_FALSE) {
+                                int pos_x = (int)(x * (float)window->w);
+                                int pos_y = (int)(y * (float)window->h);
+                                if (pos_x < 0) {
+                                    pos_x = 0;
+                                }
+                                if (pos_x > window->w - 1) {
+                                    pos_x = window->w - 1;
+                                }
+                                if (pos_y < 0) {
+                                    pos_y = 0;
+                                }
+                                if (pos_y > window->h - 1) {
+                                    pos_y = window->h - 1;
+                                }
+#ifdef __ANDROID__
+                                __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                                    "  -> Sending mouse DOWN at (%d,%d)", pos_x, pos_y);
+#endif
+                                SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
+                                SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
+                            } else {
+#ifdef __ANDROID__
+                                __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                                    "  -> SKIPPED (finger_touching=TRUE)");
+#endif
                             }
-                            if (pos_y > window->h - 1) {
-                                pos_y = window->h - 1;
+                        } else {
+                            if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
+#ifdef __ANDROID__
+                                __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                                    "  -> Sending mouse UP");
+#endif
+                                SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_RELEASED, SDL_BUTTON_LEFT);
                             }
-                            SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
-                            SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
+                        }
+                    }
+                }
+                
+                /* Track single finger state (for non-multitouch mode) */
+                /* 鍙湁鏈铏氭嫙鎺т欢鍗犵敤鐨勮Е鎽哥偣鎵嶄細鏇存柊璺熻釜鐘舵€?*/
+                if (!multitouch_enabled && !isConsumed) {
+                    if (down) {
+                        if (finger_touching == SDL_FALSE) {
+                            finger_touching = SDL_TRUE;
+                            track_touchid = id;
+                            track_fingerid = fingerid;
                         }
                     } else {
                         if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
-                            SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_RELEASED, SDL_BUTTON_LEFT);
+                            finger_touching = SDL_FALSE;
                         }
                     }
                 }
-                if (down) {
-                    if (finger_touching == SDL_FALSE) {
-                        finger_touching = SDL_TRUE;
-                        track_touchid = id;
-                        track_fingerid = fingerid;
-                    }
-                } else {
+                /* 琚崰鐢ㄧ殑瑙︽懜鐐归噴鏀炬椂锛屼篃闇€瑕佹鏌ユ槸鍚﹂渶瑕侀噸缃姸鎬?*/
+                else if (!multitouch_enabled && isConsumed && !down) {
+                    /* 濡傛灉琚崰鐢ㄧ殑瑙︽懜鐐归噴鏀撅紝涓斿畠鏄綋鍓嶈窡韪殑瑙︽懜鐐癸紝閲嶇疆鐘舵€?*/
                     if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
                         finger_touching = SDL_FALSE;
+#ifdef __ANDROID__
+                        __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                            "Consumed finger released, resetting finger_touching state");
+#endif
                     }
                 }
             }
@@ -382,22 +592,39 @@ int SDL_SendTouchMotion(SDL_TouchID id, SDL_FingerID fingerid, SDL_Window *windo
         if (mouse->touch_mouse_events) {
             if (id != SDL_MOUSE_TOUCHID) {
                 if (window) {
-                    if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
-                        int pos_x = (int)(x * (float)window->w);
-                        int pos_y = (int)(y * (float)window->h);
-                        if (pos_x < 0) {
-                            pos_x = 0;
-                        }
-                        if (pos_x > window->w - 1) {
-                            pos_x = window->w - 1;
-                        }
-                        if (pos_y < 0) {
-                            pos_y = 0;
+                    if (multitouch_enabled) {
+                        /* Multi-touch mode: update finger position */
+                        SDL_UpdateMultitouchFinger(fingerid, x, y);
+                        
+                        /* Only active finger controls cursor movement */
+                        if (fingerid == multitouch_active_finger && finger_touching == SDL_TRUE) {
+                            int pos_x = (int)(x * (float)window->w);
+                            int pos_y = (int)(y * (float)window->h);
+                            if (pos_x < 0) pos_x = 0;
+                            if (pos_x > window->w - 1) pos_x = window->w - 1;
+                            if (pos_y < 0) pos_y = 0;
+                            if (pos_y > window->h - 1) pos_y = window->h - 1;
+                            SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
                         }
-                        if (pos_y > window->h - 1) {
-                            pos_y = window->h - 1;
+                    } else {
+                        /* Original single-touch behavior */
+                        if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
+                            int pos_x = (int)(x * (float)window->w);
+                            int pos_y = (int)(y * (float)window->h);
+                            if (pos_x < 0) {
+                                pos_x = 0;
+                            }
+                            if (pos_x > window->w - 1) {
+                                pos_x = window->w - 1;
+                            }
+                            if (pos_y < 0) {
+                                pos_y = 0;
+                            }
+                            if (pos_y > window->h - 1) {
+                                pos_y = window->h - 1;
+                            }
+                            SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
                         }
-                        SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
                     }
                 }
             }
@@ -497,3 +724,4 @@ void SDL_TouchQuit(void)
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
+
