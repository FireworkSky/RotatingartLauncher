diff --git a/../../SDL_original_2301/src/core/android/SDL_android.c b/../../SDL/src/core/android/SDL_android.c
index 60620d814..20aaafbb9 100644
--- a/../../SDL_original_2301/src/core/android/SDL_android.c
+++ b/../../SDL/src/core/android/SDL_android.c
@@ -48,6 +48,7 @@
 #include <pthread.h>
 #include <sys/types.h>
 #include <unistd.h>
+#include <stdlib.h>  /* for getenv() */
 #include <dlfcn.h>
 
 #define SDL_JAVA_PREFIX                               org_libsdl_app
@@ -74,6 +75,12 @@ JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeRunMain)(
     JNIEnv *env, jclass cls,
     jstring library, jstring function, jobject array);
 
+JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvCurrent)(
+        JNIEnv *env, jclass cls);
+
+JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvNull)(
+        JNIEnv *env, jclass cls);
+
 JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeDropFile)(
     JNIEnv *env, jclass jcls,
     jstring filename);
@@ -118,6 +125,34 @@ JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouse)(
     JNIEnv *env, jclass jcls,
     jint button, jint action, jfloat x, jfloat y, jboolean relative);
 
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseDirect)(
+    JNIEnv *env, jclass jcls,
+    jint button, jint action, jfloat x, jfloat y, jboolean relative);
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseButton)(
+    JNIEnv *env, jclass jcls,
+    jint sdlButton, jint pressed, jfloat x, jfloat y);
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseButtonOnly)(
+    JNIEnv *env, jclass jcls,
+    jint sdlButton, jint pressed);
+
+JNIEXPORT jint JNICALL SDL_JAVA_INTERFACE(nativeGetMouseStateX)(
+    JNIEnv *env, jclass jcls);
+
+JNIEXPORT jint JNICALL SDL_JAVA_INTERFACE(nativeGetMouseStateY)(
+    JNIEnv *env, jclass jcls);
+
+/* 铏氭嫙鎺т欢瑙︽懜鐐圭鐞?*/
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeConsumeFingerTouch)(
+    JNIEnv *env, jclass jcls, jint fingerId);
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeReleaseFingerTouch)(
+    JNIEnv *env, jclass jcls, jint fingerId);
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeClearConsumedFingers)(
+    JNIEnv *env, jclass jcls);
+
 JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeAccel)(
     JNIEnv *env, jclass jcls,
     jfloat x, jfloat y, jfloat z);
@@ -174,6 +209,8 @@ static JNINativeMethod SDLActivity_tab[] = {
     { "nativeGetVersion", "()Ljava/lang/String;", SDL_JAVA_INTERFACE(nativeGetVersion) },
     { "nativeSetupJNI", "()I", SDL_JAVA_INTERFACE(nativeSetupJNI) },
     { "nativeRunMain", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)I", SDL_JAVA_INTERFACE(nativeRunMain) },
+    {"nativeAndroidJNISetEnvCurrent", "()I", SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvCurrent)},
+    {"nativeAndroidJNISetEnvNull", "()I", SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvNull)},
     { "onNativeDropFile", "(Ljava/lang/String;)V", SDL_JAVA_INTERFACE(onNativeDropFile) },
     { "nativeSetScreenResolution", "(IIIIF)V", SDL_JAVA_INTERFACE(nativeSetScreenResolution) },
     { "onNativeResize", "()V", SDL_JAVA_INTERFACE(onNativeResize) },
@@ -186,6 +223,14 @@ static JNINativeMethod SDLActivity_tab[] = {
     { "onNativeKeyboardFocusLost", "()V", SDL_JAVA_INTERFACE(onNativeKeyboardFocusLost) },
     { "onNativeTouch", "(IIIFFF)V", SDL_JAVA_INTERFACE(onNativeTouch) },
     { "onNativeMouse", "(IIFFZ)V", SDL_JAVA_INTERFACE(onNativeMouse) },
+    { "onNativeMouseDirect", "(IIFFZ)V", SDL_JAVA_INTERFACE(onNativeMouseDirect) },
+    { "onNativeMouseButton", "(IIFF)V", SDL_JAVA_INTERFACE(onNativeMouseButton) },
+    { "onNativeMouseButtonOnly", "(II)V", SDL_JAVA_INTERFACE(onNativeMouseButtonOnly) },
+    { "nativeGetMouseStateX", "()I", SDL_JAVA_INTERFACE(nativeGetMouseStateX) },
+    { "nativeGetMouseStateY", "()I", SDL_JAVA_INTERFACE(nativeGetMouseStateY) },
+    { "nativeConsumeFingerTouch", "(I)V", SDL_JAVA_INTERFACE(nativeConsumeFingerTouch) },
+    { "nativeReleaseFingerTouch", "(I)V", SDL_JAVA_INTERFACE(nativeReleaseFingerTouch) },
+    { "nativeClearConsumedFingers", "()V", SDL_JAVA_INTERFACE(nativeClearConsumedFingers) },
     { "onNativeAccel", "(FFF)V", SDL_JAVA_INTERFACE(onNativeAccel) },
     { "onNativeClipboardChanged", "()V", SDL_JAVA_INTERFACE(onNativeClipboardChanged) },
     { "nativeLowMemory", "()V", SDL_JAVA_INTERFACE(nativeLowMemory) },
@@ -258,7 +303,7 @@ JNIEXPORT void JNICALL SDL_JAVA_CONTROLLER_INTERFACE(onNativeHat)(
 JNIEXPORT jint JNICALL SDL_JAVA_CONTROLLER_INTERFACE(nativeAddJoystick)(
     JNIEnv *env, jclass jcls,
     jint device_id, jstring device_name, jstring device_desc, jint vendor_id, jint product_id,
-    jboolean is_accelerometer, jint button_mask, jint naxes, jint axis_mask, jint nhats, jint nballs);
+    jboolean is_accelerometer, jint button_mask, jint naxes, jint axis_mask, jint nhats, jint nballs, jboolean can_rumble);
 
 JNIEXPORT jint JNICALL SDL_JAVA_CONTROLLER_INTERFACE(nativeRemoveJoystick)(
     JNIEnv *env, jclass jcls,
@@ -278,7 +323,7 @@ static JNINativeMethod SDLControllerManager_tab[] = {
     { "onNativePadUp", "(II)I", SDL_JAVA_CONTROLLER_INTERFACE(onNativePadUp) },
     { "onNativeJoy", "(IIF)V", SDL_JAVA_CONTROLLER_INTERFACE(onNativeJoy) },
     { "onNativeHat", "(IIII)V", SDL_JAVA_CONTROLLER_INTERFACE(onNativeHat) },
-    { "nativeAddJoystick", "(ILjava/lang/String;Ljava/lang/String;IIZIIIII)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeAddJoystick) },
+    { "nativeAddJoystick", "(ILjava/lang/String;Ljava/lang/String;IIZIIIIIZ)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeAddJoystick) },
     { "nativeRemoveJoystick", "(I)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeRemoveJoystick) },
     { "nativeAddHaptic", "(ILjava/lang/String;)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeAddHaptic) },
     { "nativeRemoveHaptic", "(I)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeRemoveHaptic) }
@@ -361,6 +406,7 @@ static jclass mControllerManagerClass;
 static jmethodID midPollInputDevices;
 static jmethodID midPollHapticDevices;
 static jmethodID midHapticRun;
+static jmethodID midHapticRumble;
 static jmethodID midHapticStop;
 
 /* Accelerometer data storage */
@@ -448,6 +494,8 @@ JNIEnv *Android_JNI_GetEnv(void)
 }
 
 /* Set up an external thread for using JNI with Android_JNI_GetEnv() */
+/* EXPORTED: Used by glibc_bridge to setup JNI before Box64 execution */
+__attribute__((visibility("default")))
 int Android_JNI_SetupThread(void)
 {
     JNIEnv *env;
@@ -721,10 +769,12 @@ JNIEXPORT void JNICALL SDL_JAVA_CONTROLLER_INTERFACE(nativeSetupJNI)(JNIEnv *env
                                                      "pollHapticDevices", "()V");
     midHapticRun = (*env)->GetStaticMethodID(env, mControllerManagerClass,
                                              "hapticRun", "(IFI)V");
+    midHapticRumble = (*env)->GetStaticMethodID(env, mControllerManagerClass,
+                                                "hapticRumble", "(IFFI)V");
     midHapticStop = (*env)->GetStaticMethodID(env, mControllerManagerClass,
                                               "hapticStop", "(I)V");
 
-    if (!midPollInputDevices || !midPollHapticDevices || !midHapticRun || !midHapticStop) {
+    if (!midPollInputDevices || !midPollHapticDevices || !midHapticRun || !midHapticRumble || !midHapticStop) {
         __android_log_print(ANDROID_LOG_WARN, "SDL", "Missing some Java callbacks, do you have the latest version of SDLControllerManager.java?");
     }
 
@@ -830,6 +880,14 @@ JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeRunMain)(JNIEnv *env, jclass cls,
     return status;
 }
 
+JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvCurrent)(JNIEnv *env, jclass cls) {
+    return Android_JNI_SetEnv(env);
+}
+
+JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvNull)(JNIEnv *env, jclass cls) {
+    return Android_JNI_SetEnv(NULL);
+}
+
 /* Drop file */
 JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeDropFile)(
     JNIEnv *env, jclass jcls,
@@ -994,13 +1052,13 @@ JNIEXPORT jint JNICALL SDL_JAVA_CONTROLLER_INTERFACE(nativeAddJoystick)(
     JNIEnv *env, jclass jcls,
     jint device_id, jstring device_name, jstring device_desc,
     jint vendor_id, jint product_id, jboolean is_accelerometer,
-    jint button_mask, jint naxes, jint axis_mask, jint nhats, jint nballs)
+    jint button_mask, jint naxes, jint axis_mask, jint nhats, jint nballs, jboolean can_rumble)
 {
     int retval;
     const char *name = (*env)->GetStringUTFChars(env, device_name, NULL);
     const char *desc = (*env)->GetStringUTFChars(env, device_desc, NULL);
 
-    retval = Android_AddJoystick(device_id, name, desc, vendor_id, product_id, is_accelerometer ? SDL_TRUE : SDL_FALSE, button_mask, naxes, axis_mask, nhats, nballs);
+    retval = Android_AddJoystick(device_id, name, desc, vendor_id, product_id, is_accelerometer ? SDL_TRUE : SDL_FALSE, button_mask, naxes, axis_mask, nhats, nballs, can_rumble);
 
     (*env)->ReleaseStringUTFChars(env, device_name, name);
     (*env)->ReleaseStringUTFChars(env, device_desc, desc);
@@ -1176,6 +1234,84 @@ JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouse)(
     SDL_UnlockMutex(Android_ActivityMutex);
 }
 
+/* Mouse Direct - same as onNativeMouse but without state check */
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseDirect)(
+    JNIEnv *env, jclass jcls,
+    jint button, jint action, jfloat x, jfloat y, jboolean relative)
+{
+    SDL_LockMutex(Android_ActivityMutex);
+
+    Android_OnMouseDirect(Android_Window, button, action, x, y, relative);
+
+    SDL_UnlockMutex(Android_ActivityMutex);
+}
+
+/* Direct mouse button - bypasses state tracking for virtual controls */
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseButton)(
+    JNIEnv *env, jclass jcls,
+    jint sdlButton, jint pressed, jfloat x, jfloat y)
+{
+    SDL_LockMutex(Android_ActivityMutex);
+
+    Android_OnMouseButtonDirect(Android_Window, sdlButton, pressed, x, y);
+
+    SDL_UnlockMutex(Android_ActivityMutex);
+}
+
+/* Mouse button only - no cursor movement, for virtual button controls */
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseButtonOnly)(
+    JNIEnv *env, jclass jcls,
+    jint sdlButton, jint pressed)
+{
+    SDL_LockMutex(Android_ActivityMutex);
+
+    Android_OnMouseButtonOnly(Android_Window, sdlButton, pressed);
+
+    SDL_UnlockMutex(Android_ActivityMutex);
+}
+
+/* Get current mouse X position */
+JNIEXPORT jint JNICALL SDL_JAVA_INTERFACE(nativeGetMouseStateX)(
+    JNIEnv *env, jclass jcls)
+{
+    int x = 0;
+    SDL_GetMouseState(&x, NULL);
+    return (jint)x;
+}
+
+/* Get current mouse Y position */
+JNIEXPORT jint JNICALL SDL_JAVA_INTERFACE(nativeGetMouseStateY)(
+    JNIEnv *env, jclass jcls)
+{
+    int y = 0;
+    SDL_GetMouseState(NULL, &y);
+    return (jint)y;
+}
+
+/* 澶栭儴鍑芥暟澹版槑锛堝湪 SDL_touch.c 涓畾涔夛級 */
+extern void SDL_ConsumeFingerTouch(int fingerId);
+extern void SDL_ReleaseFingerTouch(int fingerId);
+extern void SDL_ClearConsumedFingers(void);
+
+/* 铏氭嫙鎺т欢瑙︽懜鐐圭鐞?- 琚爣璁扮殑瑙︽懜鐐逛笉浼氳浆鎹负榧犳爣浜嬩欢 */
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeConsumeFingerTouch)(
+    JNIEnv *env, jclass jcls, jint fingerId)
+{
+    SDL_ConsumeFingerTouch((int)fingerId);
+}
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeReleaseFingerTouch)(
+    JNIEnv *env, jclass jcls, jint fingerId)
+{
+    SDL_ReleaseFingerTouch((int)fingerId);
+}
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeClearConsumedFingers)(
+    JNIEnv *env, jclass jcls)
+{
+    SDL_ClearConsumedFingers();
+}
+
 /* Accelerometer */
 JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeAccel)(
     JNIEnv *env, jclass jcls,
@@ -1406,10 +1542,35 @@ ANativeWindow *Android_JNI_GetNativeWindow(void)
     jobject s;
     JNIEnv *env = Android_JNI_GetEnv();
 
+    __android_log_print(ANDROID_LOG_INFO, "SDL_JNI", "Android_JNI_GetNativeWindow called");
+    __android_log_print(ANDROID_LOG_INFO, "SDL_JNI", "  env=%p, mActivityClass=%p, midGetNativeSurface=%p",
+                        env, mActivityClass, midGetNativeSurface);
+
+    if (!env) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  ERROR: JNIEnv is NULL!");
+        return NULL;
+    }
+
+    if (!mActivityClass) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  ERROR: mActivityClass is NULL! nativeSetupJNI not called?");
+        return NULL;
+    }
+
+    if (!midGetNativeSurface) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  ERROR: midGetNativeSurface is NULL!");
+        return NULL;
+    }
+
     s = (*env)->CallStaticObjectMethod(env, mActivityClass, midGetNativeSurface);
+    __android_log_print(ANDROID_LOG_INFO, "SDL_JNI", "  getNativeSurface() returned: %p", s);
+
     if (s) {
         anw = ANativeWindow_fromSurface(env, s);
+        __android_log_print(ANDROID_LOG_INFO, "SDL_JNI", "  ANativeWindow_fromSurface returned: %p", anw);
         (*env)->DeleteLocalRef(env, s);
+    } else {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  ERROR: getNativeSurface() returned NULL!");
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  This means SDLActivity.mSurface is null or Surface not ready");
     }
 
     return anw;
@@ -2155,6 +2316,7 @@ int Android_JNI_GetPowerInfo(int *plugged, int *charged, int *battery, int *seco
 /* Add all touch devices */
 void Android_JNI_InitTouch()
 {
+
     JNIEnv *env = Android_JNI_GetEnv();
     (*env)->CallStaticVoidMethod(env, mActivityClass, midInitTouch);
 }
@@ -2177,6 +2339,12 @@ void Android_JNI_HapticRun(int device_id, float intensity, int length)
     (*env)->CallStaticVoidMethod(env, mControllerManagerClass, midHapticRun, device_id, intensity, length);
 }
 
+void Android_JNI_HapticRumble(int device_id, float low_frequency_intensity, float high_frequency_intensity, int length)
+{
+    JNIEnv *env = Android_JNI_GetEnv();
+    (*env)->CallStaticVoidMethod(env, mControllerManagerClass, midHapticRumble, device_id, low_frequency_intensity, high_frequency_intensity, length);
+}
+
 void Android_JNI_HapticStop(int device_id)
 {
     JNIEnv *env = Android_JNI_GetEnv();
@@ -2550,6 +2718,14 @@ void Android_JNI_GetManifestEnvironmentVariables(void)
 
     if (!bHasEnvironmentVariables) {
         JNIEnv *env = Android_JNI_GetEnv();
+        /* Box64 fix: Check if JNIEnv is valid before using it
+         * When running from Box64 emulated threads, the JNI environment may not be
+         * properly attached, which would cause CallStaticBooleanMethod to crash. */
+        if (!env) {
+            __android_log_print(ANDROID_LOG_WARN, "SDL",
+                "Android_JNI_GetManifestEnvironmentVariables: JNIEnv is NULL, skipping (Box64 thread?)");
+            return;
+        }
         SDL_bool ret = (*env)->CallStaticBooleanMethod(env, mActivityClass, midGetManifestEnvironmentVariables);
         if (ret) {
             bHasEnvironmentVariables = SDL_TRUE;
